<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>æ‹¼è±†å›¾çº¸ç”Ÿæˆå™¨-å¯çˆ±ç²‰çº¢ç‰ˆ</title>
    <style>
        /* --- ç²‰çº¢è‰²å¯çˆ±é£æ ¼å…¨å±€æ ·å¼ --- */
        :root {
            --primary-color: #FF69B4; /* çƒ­æƒ…ç²‰çº¢ */
            --primary-hover: #FF1493; /* æ·±ç²‰çº¢ */
            --accent-color: #FFB6C1; /* æµ…ç²‰çº¢ */
            --bg-primary: #FFF0F5; /* è–°è¡£è‰çº¢èƒŒæ™¯ */
            --bg-secondary: #FFFFFF;
            --text-primary: #2C3E50;
            --text-secondary: #FF69B4;
            --border-color: #FFB6C1;
            --shadow-sm: 0 4px 8px rgba(255, 105, 180, 0.15);
            --shadow-md: 0 8px 16px rgba(255, 105, 180, 0.2);
            --shadow-lg: 0 12px 24px rgba(255, 105, 180, 0.25);
            --radius: 15px;
            --header-height: 70px;
            --tools-height: 15vh;
        }

        * { 
            box-sizing: border-box; 
            margin: 0; 
            padding: 0; 
        }
        
        body { 
            font-family: 'Comic Sans MS', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background: linear-gradient(135deg, #FFB6C1 0%, #FFC0CB 50%, #FFD1DC 100%); 
            color: var(--text-primary); 
            line-height: 1.6;
            overflow-x: hidden;
            -webkit-tap-highlight-color: transparent;
            min-height: 100vh;
            touch-action: manipulation;
        }
        
        h1, h2, h3 { 
            font-weight: 700; 
            color: var(--primary-color);
            text-shadow: 2px 2px 4px rgba(255, 182, 193, 0.3);
        }
        
        button { 
            cursor: pointer; 
            border: none; 
            border-radius: 25px; 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
            min-height: 44px;
            font-weight: 600;
            position: relative;
            overflow: hidden;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        button:hover::before {
            width: 300px;
            height: 300px;
        }
        
        .btn { 
            padding: 0.8rem 1.4rem; 
            font-size: 1rem; 
            background: linear-gradient(45deg, var(--primary-color), var(--accent-color)); 
            color: white; 
            box-shadow: var(--shadow-sm);
            border: 2px solid transparent;
        }
        
        .btn:hover { 
            background: linear-gradient(45deg, var(--primary-hover), var(--primary-color)); 
            transform: translateY(-3px) scale(1.05); 
            box-shadow: var(--shadow-md); 
        }
        
        .btn-secondary { 
            background: linear-gradient(45deg, #FFC0CB, #FFB6C1); 
            color: white; 
        }
        
        .btn-icon { 
            background: rgba(255, 255, 255, 0.9); 
            color: var(--primary-color); 
            font-size: 1.2rem; 
            padding: 0.6rem; 
            border-radius: 50%; 
            width: 44px; 
            height: 44px; 
            border: 2px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .btn-icon:hover { 
            background: var(--accent-color); 
            transform: scale(1.1) rotate(10deg);
        }
        
        .btn-icon.active { 
            background: var(--primary-color); 
            color: white; 
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 105, 180, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 105, 180, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 105, 180, 0); }
        }

        /* --- æ¿€æ´»ç•Œé¢å¯çˆ±é£æ ¼ --- */
        .activation-screen {
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: linear-gradient(135deg, #FF69B4 0%, #FFB6C1 50%, #FFC0CB 100%);
            display: flex; 
            justify-content: center; 
            align-items: center; 
            z-index: 10000;
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
        
        .activation-card {
            background: white; 
            border-radius: 20px; 
            padding: 2.5rem;
            box-shadow: var(--shadow-lg); 
            max-width: 400px; 
            width: 90%;
            text-align: center;
            border: 3px solid var(--accent-color);
            position: relative;
            overflow: hidden;
        }

        .activation-card::before {
            content: 'ğŸŒ¸';
            position: absolute;
            top: -20px;
            right: -20px;
            font-size: 80px;
            opacity: 0.1;
            transform: rotate(-15deg);
        }
        
        .activation-card h2 { 
            margin-bottom: 1.5rem; 
            color: var(--primary-color); 
            font-size: 1.5rem; 
        }
        
        .activation-input {
            width: 100%; 
            padding: 1rem; 
            border: 3px solid var(--border-color);
            border-radius: 25px; 
            font-size: 1rem; 
            margin-bottom: 1rem;
            transition: all 0.3s;
            background: rgba(255, 255, 255, 0.9);
        }
        
        .activation-input:focus { 
            outline: none; 
            border-color: var(--primary-color); 
            box-shadow: 0 0 0 5px rgba(255, 105, 180, 0.2); 
            transform: scale(1.02);
        }
        
        .activation-error {
            color: #FF1493; 
            font-size: 0.9rem; 
            margin-bottom: 1rem;
            display: none; 
            padding: 0.8rem; 
            background: rgba(255, 20, 147, 0.1); 
            border-radius: 15px;
            border: 2px solid #FF1493;
        }
        
        .activation-success {
            color: #FF69B4; 
            font-size: 0.9rem; 
            margin-bottom: 1rem;
            display: none; 
            padding: 0.8rem; 
            background: rgba(255, 105, 180, 0.1); 
            border-radius: 15px;
            border: 2px solid #FFB6C1;
        }
        
        .activation-info {
            font-size: 0.85rem; 
            color: var(--text-secondary);
            margin-top: 1.5rem; 
            line-height: 1.5;
            padding: 1rem;
            background: rgba(255, 182, 193, 0.1);
            border-radius: 15px;
        }

        /* --- ä¸»ç•Œé¢å¯çˆ±é£æ ¼ --- */
        .home-screen {
            display: none;
            min-height: 100vh;
            flex-direction: column;
            background: linear-gradient(135deg, #FFB6C1 0%, #FFC0CB 50%, #FFD1DC 100%);
            padding: 2rem 1rem;
            position: relative;
            overflow: hidden;
        }

        .home-screen::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y="50" font-size="100" fill="rgba(255,255,255,0.05)">ğŸŒ¸</text></svg>');
            animation: float 20s infinite linear;
        }

        @keyframes float {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
        
        .home-header {
            text-align: center;
            margin-bottom: 3rem;
            color: white;
            position: relative;
            z-index: 1;
        }
        
        .home-header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.2);
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }
        
        .home-header p {
            font-size: 1.1rem;
            opacity: 0.9;
            max-width: 600px;
            margin: 0 auto;
            line-height: 1.6;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
        }
        
        .home-upload-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            z-index: 1;
        }
        
        .home-upload-area {
            background: white;
            border-radius: 25px; 
            padding: 4rem 3rem;
            text-align: center; 
            box-shadow: var(--shadow-lg); 
            max-width: 500px;
            width: 100%;
            cursor: pointer; 
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            border: 3px dashed var(--primary-color);
            position: relative;
            overflow: hidden;
        }

        .home-upload-area::before {
            content: 'ğŸ“¸';
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 30px;
            opacity: 0.3;
        }
        
        .home-upload-area:hover {
            transform: translateY(-8px) scale(1.02); 
            box-shadow: 0 20px 40px rgba(255, 105, 180, 0.3); 
            background: rgba(255, 255, 255, 0.95);
            border-color: var(--primary-hover);
        }
        
        .home-upload-area.dragover {
            background: rgba(255, 105, 180, 0.1); 
            border-color: var(--primary-hover);
            transform: scale(1.05);
        }
        
        .upload-icon {
            font-size: 4rem;
            color: var(--primary-color);
            margin-bottom: 1.5rem;
            animation: pulse 2s infinite;
        }
        
        .upload-text {
            font-size: 1.3rem;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            font-weight: 600;
        }
        
        .upload-subtext {
            font-size: 1rem;
            color: var(--text-secondary);
        }

        /* --- åº”ç”¨ç•Œé¢å¯çˆ±é£æ ¼ --- */
        .app-screen {
            display: none;
            min-height: 100vh;
            background: var(--bg-primary);
        }
        
        .app-header {
            position: sticky;
            top: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 2px solid var(--border-color);
            padding: 1rem;
            z-index: 100;
            box-shadow: var(--shadow-sm);
        }
        
        .app-header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 1rem;
        }
        
        .app-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-color);
            text-shadow: 1px 1px 2px rgba(255, 105, 180, 0.2);
        }
        
        .app-subtitle {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
            max-width: 400px;
            line-height: 1.3;
        }
        
        .header-controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .main-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem 1rem;
        }
        
        .content-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 2rem;
        }
        
        /* --- åŒºå—å¯çˆ±é£æ ¼ --- */
        .section {
            background: white;
            border-radius: var(--radius); 
            padding: 1.5rem;
            box-shadow: var(--shadow-sm);
            border: 2px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }

        .section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
        }
        
        .section-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid var(--primary-color);
        }
        
        .section-title::before {
            content: 'ğŸ’•';
            margin-right: 10px;
            font-size: 1.2em;
        }
        
        /* --- ä¸Šä¼ åŒºåŸŸå¯çˆ±é£æ ¼ --- */
        .upload-area {
            border: 3px dashed var(--primary-color); 
            border-radius: var(--radius); 
            padding: 2rem;
            text-align: center; 
            cursor: pointer; 
            transition: all 0.3s;
            background: rgba(255, 182, 193, 0.05);
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .upload-area:hover, .upload-area.dragover { 
            background: rgba(255, 105, 180, 0.1); 
            border-color: var(--primary-hover);
            transform: translateY(-2px);
        }
        
        #file-input { display: none; }
        
        /* --- é¢œè‰²é¢„è®¾å¯çˆ±é£æ ¼ --- */
        .preset-buttons { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); 
            gap: 0.8rem; 
        }
        
        .preset-btn { 
            padding: 1rem; 
            border: 2px solid var(--border-color); 
            background: linear-gradient(45deg, rgba(255, 182, 193, 0.1), rgba(255, 192, 203, 0.1)); 
            border-radius: 15px; 
            cursor: pointer; 
            font-size: 0.95rem; 
            transition: all 0.3s;
            box-shadow: var(--shadow-sm);
            text-align: center;
            font-weight: 500;
            position: relative;
            overflow: hidden;
        }
        
        .preset-btn::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 105, 180, 0.1), transparent);
            transform: rotate(45deg);
            transition: all 0.5s;
            opacity: 0;
        }
        
        .preset-btn:hover::before {
            animation: shimmer 0.5s ease-in-out;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); opacity: 0; }
        }
        
        .preset-btn:hover {
            transform: translateY(-3px) scale(1.05); 
            box-shadow: var(--shadow-md); 
            border-color: var(--primary-color);
        }
        
        .preset-btn.active { 
            background: linear-gradient(45deg, var(--primary-color), var(--accent-color)); 
            color: white; 
            border-color: var(--primary-color);
            box-shadow: var(--shadow-md);
            transform: scale(1.05);
        }
        
        .custom-color-grid {
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(40px, 1fr)); 
            gap: 8px; 
            max-height: 200px; 
            overflow-y: auto;
            border: 2px solid var(--border-color); 
            padding: 1rem; 
            border-radius: var(--radius); 
            margin-top: 1rem;
        }
        
        .color-swatch {
            width: 32px; 
            height: 32px; 
            border-radius: 8px; 
            cursor: pointer; 
            border: 2px solid #fff; 
            transition: all 0.3s;
            position: relative;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .color-swatch:hover {
            transform: scale(1.2) rotate(5deg);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .color-swatch.active { 
            box-shadow: 0 0 0 3px var(--primary-color); 
            transform: scale(1.15);
        }
        
        /* --- è®¾ç½®åŒºåŸŸå¯çˆ±é£æ ¼ --- */
        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
        }
        
        .setting-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .setting-label {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-secondary);
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .slider {
            flex: 1;
            height: 8px;
            border-radius: 4px;
            background: var(--border-color);
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(255, 105, 180, 0.3);
            transition: all 0.3s;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(255, 105, 180, 0.4);
        }
        
        .slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(255, 105, 180, 0.3);
            transition: all 0.3s;
        }
        
        .slider-value {
            min-width: 60px;
            text-align: center;
            font-weight: 600;
            color: var(--primary-color);
            background: rgba(255, 105, 180, 0.1);
            padding: 0.5rem;
            border-radius: 15px;
        }
        
        .size-inputs { 
            display: grid; 
            grid-template-columns: 1fr auto 1fr; 
            gap: 0.5rem; 
            align-items: center;
        }
        
        .size-inputs input { 
            padding: 0.8rem; 
            border: 2px solid var(--border-color); 
            border-radius: 15px;
            font-size: 1rem;
            transition: all 0.3s;
            text-align: center;
            background: rgba(255, 255, 255, 0.9);
        }
        
        .size-inputs input:focus {
            outline: none; 
            border-color: var(--primary-color); 
            box-shadow: 0 0 0 3px rgba(255, 105, 180, 0.2);
        }
        
        .size-inputs .separator {
            font-size: 1.2rem;
            color: var(--text-secondary);
            font-weight: 600;
        }
        
        /* --- ç”»å¸ƒåŒºåŸŸå¯çˆ±é£æ ¼ --- */
        .canvas-section {
            background: linear-gradient(135deg, #FFF0F5 0%, #FFE4E1 100%);
            border-radius: var(--radius); 
            padding: 2rem;
            min-height: 400px;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        .canvas-section::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 105, 180, 0.05) 1px, transparent 1px);
            background-size: 20px 20px;
            animation: sparkle 3s linear infinite;
        }

        @keyframes sparkle {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
        
        /* ä¿®å¤ï¼šå…¨æ–°çš„å›¾çº¸é¢„è§ˆUIè®¾è®¡ - è§£å†³ç¼©æ”¾å’Œæ˜¾ç¤ºé—®é¢˜ */
        .canvas-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            background: rgba(255, 255, 255, 0.9);
            border-radius: var(--radius);
            padding: 0.8rem 1rem;
            box-shadow: var(--shadow-sm);
            z-index: 10;
        }
        
        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .zoom-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 0.5rem 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            min-height: 36px;
            font-size: 0.9rem;
        }
        
        .zoom-btn:hover {
            background: var(--primary-hover);
            transform: scale(1.1);
        }
        
        .zoom-value {
            font-weight: 600;
            min-width: 60px;
            text-align: center;
            font-size: 0.9rem;
            color: var(--primary-color);
            background: rgba(255, 105, 180, 0.1);
            padding: 0.5rem;
            border-radius: 10px;
        }
        
        /* ä¿®å¤ï¼šè§†å£å®¹å™¨æ ·å¼ - è§£å†³ç¼©æ”¾å’Œæ‹–æ‹½é—®é¢˜ */
        .canvas-viewport {
            position: relative;
            flex: 1;
            overflow: auto;
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            background: #fff;
            border: 2px solid var(--accent-color);
            /* ä¿®å¤ï¼šç¡®ä¿åœ¨ç§»åŠ¨ç«¯å¯ä»¥æ­£å¸¸æ»šåŠ¨ */
            -webkit-overflow-scrolling: touch;
            touch-action: pan-x pan-y;
            cursor: grab;
            /* ä¿®å¤ï¼šå…³é”® - è®¾ç½®å›ºå®šå°ºå¯¸é¿å…ç©ºç™½åŒºåŸŸé—®é¢˜ */
            width: 100%;
            height: 500px;
            max-width: 100%;
            max-height: 70vh;
        }
        
        .canvas-viewport.dragging {
            cursor: grabbing;
        }
        
        .canvas-content {
            position: relative;
            display: inline-block;
            transform-origin: 0 0;
            transition: transform 0.2s ease;
            /* ä¿®å¤ï¼šç¡®ä¿å†…å®¹ä¸ä¼šè¢«æˆªæ–­ */
            min-width: 100%;
            min-height: 100%;
        }
        
        #pattern-canvas { 
            display: block; 
            border-radius: var(--radius); 
            cursor: crosshair; 
            image-rendering: pixelated; 
            image-rendering: -moz-crisp-edges; 
            image-rendering: crisp-edges;
        }
        
        /* --- ç¼–è¾‘æ¨¡å¼å¯çˆ±é£æ ¼ --- */
        .edit-mode-screen {
            display: none;
            min-height: 100vh;
            background: var(--bg-primary);
            flex-direction: column;
        }
        
        .edit-mode-header {
            position: sticky;
            top: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 2px solid var(--border-color);
            padding: 1rem;
            z-index: 100;
            box-shadow: var(--shadow-sm);
        }
        
        .edit-mode-header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 1rem;
        }
        
        .edit-mode-title {
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--primary-color);
        }
        
        .edit-mode-canvas-container {
            flex: 1;
            background: linear-gradient(135deg, #FFF0F5 0%, #FFE4E1 100%);
            padding: 2rem;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
            height: calc(85vh - var(--header-height));
        }
        
        .edit-mode-tools {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.98);
            border-top: 2px solid var(--border-color);
            padding: 1rem;
            z-index: 998;
            box-shadow: 0 -4px 20px rgba(255, 105, 180, 0.15);
            backdrop-filter: blur(10px);
            height: var(--tools-height);
            max-height: 15vh;
            overflow-y: auto;
        }
        
        .edit-tools-grid {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            align-items: start;
        }
        
        .edit-tool-group {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }
        
        .edit-tool-label {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 0.5rem;
        }
        
        .checkbox-group { 
            display: grid; 
            grid-template-columns: repeat(2, 1fr); 
            gap: 0.8rem; 
        }
        
        .checkbox-group label { 
            display: flex; 
            align-items: center; 
            cursor: pointer; 
            font-size: 0.9rem;
            transition: all 0.3s;
            padding: 0.5rem;
            border-radius: 10px;
        }
        
        .checkbox-group label:hover {
            background: rgba(255, 105, 180, 0.1);
            transform: scale(1.02);
        }
        
        .checkbox-group input[type="checkbox"] { 
            margin-right: 0.5rem; 
            width: 18px; 
            height: 18px;
            cursor: pointer;
        }
        
        .action-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.8rem;
        }
        
        .action-btn {
            padding: 0.8rem;
            border: none;
            border-radius: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
            min-height: 44px;
        }
        
        .action-btn.highlight {
            background: linear-gradient(45deg, var(--accent-color), var(--primary-color));
            color: white;
        }
        
        .action-btn.hide {
            background: linear-gradient(45deg, #FFC0CB, #FFB6C1);
            color: white;
        }
        
        .action-btn.clear {
            background: var(--border-color);
            color: var(--text-primary);
        }
        
        .action-btn.download {
            background: linear-gradient(45deg, #FF69B4, #FF1493);
            color: white;
            grid-column: span 3;
        }
        
        .action-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .excluded-colors {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .excluded-color-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0.8rem;
            background: rgba(255, 182, 193, 0.1);
            border-radius: 10px;
            font-size: 0.85rem;
        }
        
        .excluded-color-swatch {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }
        
        .remove-exclusion {
            cursor: pointer;
            color: var(--text-secondary);
            font-weight: bold;
            font-size: 1rem;
        }
        
        .remove-exclusion:hover {
            color: var(--primary-color);
        }
        
        /* --- ä¸‹è½½åŒºåŸŸå¯çˆ±é£æ ¼ --- */
        .download-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }
        
        .status-display {
            background: rgba(255, 182, 193, 0.1);
            border-radius: var(--radius);
            padding: 1rem;
            margin-top: 1rem;
            font-size: 0.9rem;
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }
        
        .status-label {
            color: var(--text-secondary);
        }
        
        .status-value {
            font-weight: 600;
            color: var(--primary-color);
        }
        
        /* --- è¿›åº¦æ¡å¯çˆ±é£æ ¼ --- */
        .progress-container {
            margin-top: 1rem;
            display: none;
        }
        
        .progress-bar {
            width: 100%;
            height: 12px;
            background: var(--border-color);
            border-radius: 6px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 6px;
        }
        
        .progress-text {
            text-align: center;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
        }
        
        /* --- è´­ç‰©æ¸…å•å¯çˆ±é£æ ¼ --- */
        .shopping-list {
            position: fixed; 
            bottom: 0; 
            left: 0; 
            right: 0;
            background: rgba(255, 255, 255, 0.98); 
            border-radius: var(--radius) var(--radius) 0 0; 
            box-shadow: 0 -4px 20px rgba(255, 105, 180, 0.15);
            padding: 1.5rem; 
            transform: translateY(100%); 
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 997; 
            max-height: 50vh; 
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }
        
        .shopping-list.visible { transform: translateY(0); }
        
        .shopping-list h3 { 
            font-size: 1.1rem; 
            margin-bottom: 1.5rem;
            color: var(--primary-color);
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--primary-color);
        }
        
        .list-items { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); 
            gap: 0.8rem; 
        }
        
        .list-item { 
            display: flex; 
            align-items: center; 
            gap: 0.6rem; 
            font-size: 0.85rem; 
            padding: 8px; 
            background: rgba(255, 182, 193, 0.1);
            border-radius: 10px;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            cursor: pointer;
        }
        
        .list-item:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .list-swatch { 
            width: 20px; 
            height: 20px; 
            border-radius: 4px; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        /* --- æµ®åŠ¨å…ƒç´ å¯çˆ±é£æ ¼ --- */
        .tooltip {
            position: fixed; 
            background: linear-gradient(135deg, var(--primary-color), var(--accent-color)); 
            color: white; 
            padding: 12px 16px; 
            border-radius: 15px;
            font-size: 0.85rem; 
            pointer-events: none; 
            z-index: 1000; 
            white-space: nowrap;
            box-shadow: var(--shadow-lg);
            backdrop-filter: blur(10px);
            max-width: 200px;
        }
        
        .coordinate-display {
            position: fixed; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98); 
            padding: 20px; 
            border-radius: 20px;
            box-shadow: var(--shadow-lg); 
            z-index: 1002; 
            display: none;
            border: 3px solid var(--primary-color);
            backdrop-filter: blur(10px);
            max-width: 90%;
            width: 300px;
        }
        
        .coordinate-display h4 { margin-bottom: 12px; color: var(--primary-color); font-size: 1.1rem; }
        .coordinate-display p { margin: 8px 0; font-size: 0.95rem; }
        .color-preview { 
            display: inline-block; 
            width: 24px; 
            height: 24px; 
            border-radius: 4px; 
            vertical-align: middle; 
            margin-left: 8px; 
            border: 1px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        /* --- é¢œè‰²é€‰æ‹©å™¨å¯çˆ±é£æ ¼ --- */
        .color-picker-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1003;
            padding: 1rem;
        }
        
        .color-picker-content {
            background: white;
            border-radius: var(--radius);
            padding: 1.5rem;
            max-width: 90vw;
            max-height: 80vh;
            overflow-y: auto;
            width: 800px;
            box-shadow: var(--shadow-lg);
        }
        
        .color-picker-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            position: sticky;
            top: 0;
            background: white;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--border-color);
        }
        
        .color-picker-header h3 {
            color: var(--text-primary);
            font-size: 1.2rem;
        }
        
        .color-picker-close {
            background: transparent;
            color: var(--text-secondary);
            font-size: 1.5rem;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .color-picker-close:hover {
            background: rgba(255, 182, 193, 0.1);
        }
        
        .color-picker-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 10px;
        }
        
        .color-picker-item {
            width: 60px;
            height: 60px;
            border-radius: 12px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .color-picker-item:hover {
            transform: scale(1.1) rotate(5deg);
            border-color: var(--primary-color);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .color-picker-item.selected {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(255, 105, 180, 0.2);
            transform: scale(1.05);
        }
        
        .color-picker-color {
            width: 35px;
            height: 35px;
            border-radius: 8px;
            border: 1px solid rgba(0,0,0,0.1);
        }
        
        .color-picker-label {
            font-size: 10px;
            font-weight: 600;
            color: var(--text-primary);
            margin-top: 4px;
            text-align: center;
        }

        /* --- é¢œè‰²æ›´æ¢åŠŸèƒ½å¼€å…³æ ·å¼ --- */
        .color-replace-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.8rem;
            background: rgba(255, 182, 193, 0.1);
            border-radius: 15px;
            margin-bottom: 1rem;
        }

        .toggle-switch {
            position: relative;
            width: 60px;
            height: 30px;
            background: var(--border-color);
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .toggle-switch.active {
            background: var(--primary-color);
        }

        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(30px);
        }

        .toggle-label {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        /* --- å…¼å®¹æ€§æç¤ºæ ·å¼ --- */
        .compatibility-warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            color: #856404;
        }

        .compatibility-warning strong {
            color: #d63031;
        }

        /* --- å“åº”å¼è®¾è®¡ --- */
        @media (max-width: 768px) {
            .home-header h1 {
                font-size: 2rem;
            }
            
            .home-upload-area {
                padding: 2rem 1.5rem;
            }
            
            .app-header-content {
                flex-direction: column;
                text-align: center;
            }
            
            .app-title {
                font-size: 1.2rem;
            }
            
            .content-grid {
                gap: 1.5rem;
            }
            
            .section {
                padding: 1rem;
            }
            
            .section-title {
                font-size: 1.1rem;
            }
            
            .preset-buttons {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .settings-grid {
                grid-template-columns: 1fr;
            }
            
            .edit-tools-grid {
                grid-template-columns: 1fr;
                gap: 0.8rem;
            }
            
            .checkbox-group {
                grid-template-columns: 1fr;
            }
            
            .action-buttons {
                grid-template-columns: 1fr;
            }
            
            .download-buttons {
                grid-template-columns: 1fr;
            }
            
            .size-inputs {
                grid-template-columns: 1fr;
                gap: 0.5rem;
            }
            
            .size-inputs .separator {
                display: none;
            }
            
            .custom-color-grid {
                grid-template-columns: repeat(auto-fill, minmax(30px, 1fr));
            }
            
            .color-swatch {
                width: 28px;
                height: 28px;
            }
            
            .color-picker-grid {
                grid-template-columns: repeat(auto-fill, minmax(45px, 1fr));
                gap: 8px;
            }
            
            .color-picker-item {
                width: 45px;
                height: 45px;
            }
            
            .color-picker-color {
                width: 30px;
                height: 30px;
            }
            
            .edit-mode-tools {
                height: 20vh;
                max-height: 20vh;
            }
            
            /* ä¿®å¤ï¼šç§»åŠ¨ç«¯ç¼©æ”¾æ§åˆ¶ä¼˜åŒ– */
            .canvas-controls {
                flex-direction: column;
                gap: 0.5rem;
                align-items: center;
            }
            
            .zoom-controls {
                order: 2;
            }
        }
        
        @media (max-width: 480px) {
            .home-header h1 {
                font-size: 1.5rem;
            }
            
            .home-upload-area {
                padding: 1.5rem 1rem;
            }
            
            .upload-icon {
                font-size: 3rem;
            }
            
            .upload-text {
                font-size: 1.1rem;
            }
            
            .main-content {
                padding: 1rem 0.5rem;
            }
            
            .section {
                padding: 0.75rem;
            }
            
            .canvas-section {
                padding: 1rem;
            }
            
            .edit-mode-canvas-container {
                padding: 1rem;
                height: calc(80vh - var(--header-height));
            }
            
            .edit-mode-tools {
                height: 20vh;
                max-height: 20vh;
                padding: 0.8rem;
            }
            
            .edit-tools-grid {
                gap: 0.6rem;
            }
            
            .action-buttons {
                grid-template-columns: 1fr;
                gap: 0.5rem;
            }
            
            .zoom-controls {
                padding: 0.6rem;
            }
            
            .zoom-btn {
                padding: 0.4rem 0.8rem;
                font-size: 0.9rem;
                min-height: 32px;
            }
        }

        /* --- åƒç´ é£è£…é¥°å…ƒç´  --- */
        .pixel-decoration {
            position: absolute;
            font-size: 20px;
            opacity: 0.1;
            pointer-events: none;
            animation: pixelFloat 6s infinite ease-in-out;
        }

        @keyframes pixelFloat {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-10px) rotate(180deg); }
        }

        .pixel-decoration:nth-child(1) { top: 10%; left: 5%; animation-delay: 0s; }
        .pixel-decoration:nth-child(2) { top: 20%; right: 10%; animation-delay: 1s; }
        .pixel-decoration:nth-child(3) { bottom: 15%; left: 8%; animation-delay: 2s; }
        .pixel-decoration:nth-child(4) { bottom: 25%; right: 5%; animation-delay: 3s; }
        .pixel-decoration:nth-child(5) { top: 50%; left: 50%; animation-delay: 4s; }
    </style>
</head>
<body>

<!-- åƒç´ é£è£…é¥°å…ƒç´  -->
<div class="pixel-decoration">ğŸŒ¸</div>
<div class="pixel-decoration">ğŸŒ·</div>
<div class="pixel-decoration">ğŸŒ¹</div>
<div class="pixel-decoration">ğŸŒº</div>
<div class="pixel-decoration">ğŸŒ¼</div>

<!-- Activation Screen -->
<div class="activation-screen" id="activation-screen">
    <div class="activation-card">
        <h2>ğŸ” æ¿€æ´»éªŒè¯</h2>
        <p style="margin-bottom: 1.5rem; color: var(--text-secondary); font-size: 0.95rem;">è¯·è¾“å…¥æ¿€æ´»ç ä»¥ä½¿ç”¨æ‹¼è±†å›¾çº¸ç”Ÿæˆå™¨</p>
        <input type="password" class="activation-input" id="activation-code" placeholder="è¯·è¾“å…¥æ¿€æ´»ç " maxlength="6">
        <div class="activation-error" id="activation-error">æ¿€æ´»ç é”™è¯¯ï¼Œè¯·é‡æ–°è¾“å…¥</div>
        <div class="activation-success" id="activation-success">æ¿€æ´»æˆåŠŸï¼æ­£åœ¨è¿›å…¥...</div>
        <button class="btn btn-primary" id="activate-btn" style="width: 100%;">æ¿€æ´»ä½¿ç”¨</button>
        <div class="activation-info">
            å¦‚éœ€è·å–æ¿€æ´»ç ï¼Œè¯·è”ç³»<br>
            <strong>æ·˜å®åº—é“ºï¼šå¤§å¸ˆç²¾å“èµ„æ–™</strong>
        </div>
    </div>
</div>

<!-- Home Screen (Upload Only) -->
<div class="home-screen" id="home-screen">
    <div class="home-header">
        <h1>ğŸŒ¸ æ‹¼è±†å›¾çº¸ç”Ÿæˆå™¨-è¥¿ç“œå“¥åˆ¶ä½œ ğŸŒ¸</h1>
        <p>ä¸“ä¸šçš„æ‹¼è±†å›¾æ¡ˆåˆ¶ä½œå·¥å…·ï¼Œé›†å¸‚é¢é¡¶å°–æ‹¼è±†è½¬æ¢æŠ€æœ¯äºä¸€ä½“çš„ç¨‹åº</p>
    </div>
    <div class="home-upload-container">
        <div class="home-upload-area" id="home-upload-area">
            <div class="upload-icon">ğŸ“¸</div>
            <div class="upload-text">ç‚¹å‡»ä¸Šä¼ å›¾ç‰‡</div>
            <div class="upload-subtext">æ”¯æŒ JPGã€PNGã€GIF æ ¼å¼ï¼Œæˆ–æ‹–æ‹½å›¾ç‰‡åˆ°æ­¤å¤„</div>
            <input type="file" id="home-file-input" accept="image/*">
        </div>
    </div>
</div>

<!-- Main App Screen -->
<div class="app-screen" id="app-screen">
    <header class="app-header">
        <div class="app-header-content">
            <div>
                <div class="app-title">æ‹¼è±†å›¾çº¸ç”Ÿæˆå™¨-è¥¿ç“œå“¥åˆ¶ä½œ</div>
                <div class="app-subtitle">ç›®å‰ä»…æˆæƒäºæ·˜å®åº—é“ºï¼šå¤§å¸ˆç²¾å“èµ„æ–™ ç‰ˆæƒå‡å·²ç™»è®° å¦‚æœ‰å‘ç°å€’å–è€…ï¼Œè¯·è”ç³»æˆ‘ä»¬</div>
            </div>
            <div class="header-controls">
                <button class="btn-icon" id="new-image-btn" title="ä¸Šä¼ æ–°å›¾ç‰‡">ğŸ“·</button>
                <button class="btn-icon" id="edit-mode-btn" title="ç‚¹å‡»è¿›å…¥ç¼–è¾‘æ¨¡å¼">âœï¸</button>
                <button class="btn-icon" id="help-btn" title="å¸®åŠ©">â“</button>
            </div>
        </div>
    </header>
    
    <main class="main-content">
        <div class="content-grid">
            <!-- Upload Section -->
            <section class="section">
                <h2 class="section-title">ğŸ“· ä¸Šä¼ å›¾ç‰‡</h2>
                <div class="upload-area" id="upload-area">
                    <p style="font-size: 1.1rem; margin-bottom: 0.5rem;">ğŸ“ ç‚¹å‡»æˆ–æ‹–æ‹½å›¾ç‰‡åˆ°æ­¤å¤„</p>
                    <p style="font-size:0.9rem; color:var(--text-secondary);">æ”¯æŒ JPG, PNG, GIF æ ¼å¼</p>
                    <input type="file" id="file-input" accept="image/*">
                </div>
            </section>

            <!-- Color Presets Section -->
            <section class="section">
                <h2 class="section-title">ğŸ¨ é¢œè‰²é¢„è®¾</h2>
                <div class="preset-buttons" id="preset-buttons"></div>
                <div id="custom-color-section" style="display:none; margin-top: 1.5rem;">
                    <label style="font-size:0.95rem; font-weight: 500;">è‡ªå®šä¹‰é¢œè‰² (ç‚¹å‡»é€‰æ‹©):</label>
                    <div class="custom-color-grid" id="custom-color-grid"></div>
                    <button class="btn btn-primary" id="save-custom-palette" style="margin-top:1rem; width:100%;">ä¿å­˜è‡ªå®šä¹‰è‰²æ¿</button>
                </div>
            </section>

            <!-- Settings Section -->
            <section class="section">
                <h2 class="section-title">ğŸ“ å›¾çº¸è®¾ç½®</h2>
                <div class="settings-grid">
                    <div class="setting-group">
                        <label class="setting-label">ç½‘æ ¼ç²’åº¦ (æ§åˆ¶ç»†èŠ‚ç¨‹åº¦)</label>
                        <div class="slider-container">
                            <input type="range" id="granularity-slider" class="slider" min="10" max="200" value="64">
                            <span class="slider-value" id="granularity-display">64 Ã— 64</span>
                        </div>
                    </div>
                    
                    <div class="setting-group">
                        <label class="setting-label">å›¾çº¸å°ºå¯¸</label>
                        <div class="size-inputs">
                            <input type="number" id="width-input" value="64" min="10" max="200" placeholder="å®½åº¦">
                            <span class="separator">Ã—</span>
                            <input type="number" id="height-input" value="64" min="10" max="200" placeholder="é«˜åº¦">
                        </div>
                    </div>
                    
                    <div class="setting-group">
                        <label class="setting-label">ç›¸ä¼¼åº¦é˜ˆå€¼ (æ§åˆ¶é¢œè‰²åˆå¹¶)</label>
                        <div class="slider-container">
                            <input type="range" id="similarity-threshold" class="slider" min="10" max="100" value="30">
                            <span class="slider-value" id="threshold-display">30</span>
                        </div>
                    </div>
                </div>
                
                <button class="btn btn-primary" id="generate-btn" style="width:100%; margin-top:1.5rem; font-size: 1.1rem; padding: 1rem;">âœ¨ ç”Ÿæˆå›¾çº¸</button>
                
                <div class="progress-container" id="progress-container">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-fill"></div>
                    </div>
                    <div class="progress-text" id="progress-text">å¤„ç†ä¸­...</div>
                </div>
            </section>

            <!-- Canvas Section -->
            <section class="section">
                <h2 class="section-title">ğŸ–¼ï¸ å›¾çº¸é¢„è§ˆ</h2>
                <div class="canvas-section" id="canvas-section">
                    <p style="color: var(--text-secondary); text-align: center;">è¯·ä¸Šä¼ å›¾ç‰‡å¹¶ç‚¹å‡»ç”Ÿæˆå›¾çº¸</p>
                </div>
            </section>

            <!-- Download Section -->
            <section class="section">
                <h2 class="section-title">ğŸ’¾ ä¸‹è½½å¯¼å‡º</h2>
                <div class="compatibility-warning" id="compatibility-warning" style="display: none;">
                    <strong>âš ï¸ å…¼å®¹æ€§æç¤º</strong><br>
                    æ£€æµ‹åˆ°æ‚¨çš„è®¾å¤‡å¯èƒ½å­˜åœ¨å…¼å®¹æ€§é—®é¢˜ï¼Œå»ºè®®ï¼š<br>
                    1. ä¼˜å…ˆä½¿ç”¨"åœ¨æ–°çª—å£æŸ¥çœ‹"åŠŸèƒ½<br>
                    2. å¦‚æœä¸‹è½½å¤±è´¥ï¼Œè¯·æˆªå›¾ä¿å­˜<br>
                    3. å»ºè®®ä½¿ç”¨Safariã€Chromeç­‰ä¸»æµæµè§ˆå™¨
                </div>
                <div class="download-buttons">
                    <button class="btn btn-primary" id="download-btn">ğŸ’¾ ä¸‹è½½é«˜æ¸…å›¾çº¸</button>
                    <button class="btn btn-secondary" id="download-stats-btn">ğŸ“Š ä¸‹è½½ç»Ÿè®¡å›¾</button>
                    <button class="btn btn-secondary" id="toggle-list-btn">ğŸ“¦ æŸ¥çœ‹ææ–™æ¸…å•</button>
                    <button class="btn btn-secondary" id="view-in-new-window-btn">ğŸ–¼ï¸ åœ¨æ–°çª—å£æŸ¥çœ‹</button>
                    <button class="btn btn-secondary" id="screenshot-guide-btn">ğŸ“· æˆªå›¾ä¿å­˜æç¤º</button>
                </div>
                
                <div class="status-display">
                    <div class="status-item">
                        <span class="status-label">å¤„ç†æ¨¡å¼:</span>
                        <span class="status-value" id="processing-mode">æœªå¤„ç†</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">åŒºåŸŸåˆå¹¶:</span>
                        <span class="status-value" id="merged-regions">0ä¸ªåŒºåŸŸ</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">èƒŒæ™¯ç§»é™¤:</span>
                        <span class="status-value" id="background-removed">æœªæ‰§è¡Œ</span>
                    </div>
                </div>
            </section>
        </div>
    </main>
</div>

<!-- Edit Mode Screen -->
<div class="edit-mode-screen" id="edit-mode-screen">
    <header class="edit-mode-header">
        <div class="edit-mode-header-content">
            <div class="edit-mode-title">ğŸ”§ ç¼–è¾‘æ¨¡å¼</div>
            <div class="header-controls">
                <button class="btn-icon" id="back-to-main-btn" title="è¿”å›ä¸»ç•Œé¢">ğŸ”™</button>
                <button class="btn-icon" id="help-edit-btn" title="å¸®åŠ©">â“</button>
            </div>
        </div>
    </header>
    
    <div class="edit-mode-canvas-container" id="edit-mode-canvas-container">
        <p style="color: var(--text-secondary); text-align: center;">è¯·å…ˆåœ¨ä¸»ç•Œé¢ç”Ÿæˆå›¾çº¸</p>
    </div>
    
    <div class="edit-mode-tools">
        <div class="edit-tools-grid">
            <!-- é¢œè‰²æ›´æ¢åŠŸèƒ½å¼€å…³ -->
            <div class="edit-tool-group">
                <div class="edit-tool-label">ğŸ¨ é¢œè‰²æ›´æ¢åŠŸèƒ½</div>
                <div class="color-replace-toggle">
                    <span class="toggle-label">å…³é—­</span>
                    <div class="toggle-switch" id="color-replace-toggle">
                        <div class="toggle-slider"></div>
                    </div>
                    <span class="toggle-label">å¼€å¯</span>
                </div>
            </div>
            
            <div class="edit-tool-group">
                <div class="edit-tool-label">æ˜¾ç¤ºé€‰é¡¹</div>
                <div class="checkbox-group">
                    <label>
                        <input type="checkbox" id="edit-show-grid" checked>
                        <span>æ˜¾ç¤ºç½‘æ ¼</span>
                    </label>
                    <label>
                        <input type="checkbox" id="edit-show-coords" checked>
                        <span>æ˜¾ç¤ºåæ ‡</span>
                    </label>
                    <label>
                        <input type="checkbox" id="edit-show-colors" checked>
                        <span>æ˜¾ç¤ºè‰²å·</span>
                    </label>
                    <label>
                        <input type="checkbox" id="edit-show-background" checked>
                        <span>æ˜¾ç¤ºèƒŒæ™¯</span>
                    </label>
                </div>
            </div>
            
            <div class="edit-tool-group">
                <div class="edit-tool-label">é¢œè‰²æ“ä½œ</div>
                <div class="action-buttons">
                    <button class="action-btn highlight" id="edit-highlight-btn">ğŸ”† é«˜äº®</button>
                    <button class="action-btn hide" id="edit-hide-btn">ğŸ‘ï¸ éšè—</button>
                    <button class="action-btn clear" id="edit-clear-highlight-btn">ğŸ”„ æ¸…é™¤</button>
                </div>
            </div>
            
            <div class="edit-tool-group">
                <div class="edit-tool-label">ğŸš« é¢œè‰²æ’é™¤</div>
                <div id="edit-excluded-colors" class="excluded-colors"></div>
            </div>
            
            <div class="edit-tool-group">
                <div class="edit-tool-label">ğŸ’¾ ä¸‹è½½å›¾çº¸</div>
                <button class="action-btn download" id="edit-download-btn">ğŸ’¾ ä¸‹è½½é«˜æ¸…å›¾çº¸</button>
            </div>
        </div>
    </div>
</div>

<!-- Floating Elements -->
<div class="tooltip" id="tooltip" style="display:none;"></div>
<div class="coordinate-display" id="coordinate-display">
    <h4>ğŸ¨ ç å­ä¿¡æ¯</h4>
    <p>ä½ç½®: <span id="coord-position"></span></p>
    <p>åæ ‡: <span id="coord-alphabet"></span></p>
    <p>è‰²å·: <span id="coord-color"></span></p>
    <p>é¢œè‰²: <span id="coord-hex"></span><span class="color-preview" id="coord-preview"></span></span></p>
    <div style="margin-top: 1rem; display: flex; gap: 0.5rem;">
        <button class="btn btn-primary" id="replace-color-btn" style="flex: 1;">æ›´æ¢é¢œè‰²</button>
    </div>
</div>
<div class="shopping-list" id="shopping-list">
    <h3>ğŸ“¦ ææ–™æ¸…å•</h3>
    <div class="list-items" id="list-items"></div>
</div>

<!-- Color Picker Modal -->
<div class="color-picker-modal" id="color-picker-modal">
    <div class="color-picker-content">
        <div class="color-picker-header">
            <h3>é€‰æ‹©æ–°é¢œè‰²</h3>
            <button class="color-picker-close" id="color-picker-close">Ã—</button>
        </div>
        <div class="color-picker-grid" id="color-picker-grid"></div>
    </div>
</div>

<script>
// --- Activation System ---
const CORRECT_CODE = '884832';

// æ¿€æ´»å‡½æ•° - å®Œå…¨é‡å†™ï¼Œç¡®ä¿æ¿€æ´»ç³»ç»Ÿæ­£å¸¸å·¥ä½œ
function activateApp() {
    console.log('=== å¼€å§‹æ¿€æ´»æµç¨‹ ===');
    
    const input = document.getElementById('activation-code');
    const errorDiv = document.getElementById('activation-error');
    const successDiv = document.getElementById('activation-success');
    const activateBtn = document.getElementById('activate-btn');
    
    if (!input) {
        console.error('æ¿€æ´»è¾“å…¥æ¡†æœªæ‰¾åˆ°');
        return;
    }
    
    const inputValue = input.value ? input.value.trim() : '';
    console.log('è¾“å…¥çš„æ¿€æ´»ç :', inputValue, 'é•¿åº¦:', inputValue.length);
    
    // æ¸…é™¤ä¹‹å‰çš„çŠ¶æ€
    errorDiv.style.display = 'none';
    successDiv.style.display = 'none';
    
    if (!inputValue) {
        errorDiv.textContent = 'è¯·è¾“å…¥æ¿€æ´»ç ';
        errorDiv.style.display = 'block';
        console.error('é”™è¯¯ï¼šæ¿€æ´»ç ä¸ºç©º');
        setTimeout(() => {
            errorDiv.style.display = 'none';
        }, 3000);
        return;
    }
    
    if (inputValue === CORRECT_CODE) {
        console.log('âœ… æ¿€æ´»ç éªŒè¯é€šè¿‡');
        
        // ç¦ç”¨è¾“å…¥å’ŒæŒ‰é’®
        input.disabled = true;
        activateBtn.disabled = true;
        
        // æ˜¾ç¤ºæˆåŠŸä¿¡æ¯
        successDiv.textContent = 'æ¿€æ´»æˆåŠŸï¼æ­£åœ¨è¿›å…¥...';
        successDiv.style.display = 'block';
        activateBtn.textContent = 'æ¿€æ´»æˆåŠŸ';
        
        // ç«‹å³ä¿å­˜æ¿€æ´»çŠ¶æ€
        sessionStorage.setItem('activated', 'true');
        sessionStorage.setItem('activation_time', new Date().toISOString());
        
        console.log('æ¿€æ´»çŠ¶æ€å·²ä¿å­˜');
        
        // ç«‹å³åˆ‡æ¢åˆ°ä¸»ç•Œé¢
        console.log('å¼€å§‹åˆ‡æ¢åˆ°ä¸»ç•Œé¢...');
        
        // å…ˆéšè—æ¿€æ´»ç•Œé¢
        document.getElementById('activation-screen').style.display = 'none';
        
        // ç¡®ä¿ä¸»ç•Œé¢å…ƒç´ å­˜åœ¨
        const homeScreen = document.getElementById('home-screen');
        if (homeScreen) {
            homeScreen.style.display = 'flex';
            console.log('ä¸»ç•Œé¢å·²æ˜¾ç¤º');
        } else {
            console.error('ä¸»ç•Œé¢å…ƒç´ æœªæ‰¾åˆ°');
        }
        
        // å¼ºåˆ¶é‡æ–°æ¸²æŸ“
        setTimeout(() => {
            console.log('å¼ºåˆ¶é‡æ–°æ¸²æŸ“é¡µé¢');
            // ç¡®ä¿æ‰€æœ‰å…ƒç´ æ­£ç¡®æ˜¾ç¤º
            document.body.style.display = 'block';
            document.body.style.visibility = 'visible';
            
            // æ£€æŸ¥æ˜¯å¦æˆåŠŸåˆ‡æ¢
            const currentDisplay = document.getElementById('activation-screen').style.display;
            const homeDisplay = document.getElementById('home-screen').style.display;
            
            console.log('å½“å‰æ¿€æ´»ç•Œé¢æ˜¾ç¤ºçŠ¶æ€:', currentDisplay);
            console.log('ä¸»ç•Œé¢æ˜¾ç¤ºçŠ¶æ€:', homeDisplay);
            
            if (currentDisplay === 'none' && homeDisplay === 'flex') {
                console.log('âœ… é¡µé¢åˆ‡æ¢æˆåŠŸ');
            } else {
                console.error('é¡µé¢åˆ‡æ¢å¯èƒ½å­˜åœ¨é—®é¢˜ï¼Œå¼ºåˆ¶è®¾ç½®');
                document.getElementById('activation-screen').style.display = 'none';
                document.getElementById('home-screen').style.display = 'flex';
            }
        }, 100);
        
    } else {
        console.log('âŒ æ¿€æ´»ç éªŒè¯å¤±è´¥');
        
        errorDiv.textContent = `æ¿€æ´»ç é”™è¯¯ï¼Œè¯·é‡æ–°è¾“å…¥ (${inputValue.length}ä½)`;
        errorDiv.style.display = 'block';
        
        // é‡æ–°å¯ç”¨è¾“å…¥å’ŒæŒ‰é’®
        input.disabled = false;
        activateBtn.disabled = false;
        input.value = '';
        input.focus();
        
        setTimeout(() => {
            errorDiv.style.display = 'none';
        }, 3000);
    }
}

// åˆå§‹åŒ–æ¿€æ´»ç³»ç»Ÿ - å®Œå…¨é‡å†™ï¼Œç¡®ä¿äº‹ä»¶æ­£ç¡®ç»‘å®š
function initializeActivation() {
    console.log('=== åˆå§‹åŒ–æ¿€æ´»ç³»ç»Ÿ ===');
    
    // æ£€æŸ¥æ˜¯å¦å·²ç»æ¿€æ´»
    if (sessionStorage.getItem('activated') === 'true') {
        console.log('ç”¨æˆ·å·²æ¿€æ´»ï¼Œç›´æ¥è¿›å…¥ä¸»åº”ç”¨');
        document.getElementById('activation-screen').style.display = 'none';
        document.getElementById('home-screen').style.display = 'flex';
        return;
    }
    
    // è·å–æ¿€æ´»ç›¸å…³å…ƒç´ 
    const activateBtn = document.getElementById('activate-btn');
    const activationInput = document.getElementById('activation-code');
    
    if (!activateBtn || !activationInput) {
        console.error('æ¿€æ´»æŒ‰é’®æˆ–è¾“å…¥æ¡†æœªæ‰¾åˆ°');
        // å»¶è¿Ÿé‡è¯•
        setTimeout(initializeActivation, 100);
        return;
    }
    
    // æ¸…é™¤ä¹‹å‰çš„äº‹ä»¶ç›‘å¬å™¨
    const newActivateBtn = activateBtn.cloneNode(true);
    activateBtn.parentNode.replaceChild(newActivateBtn, activateBtn);
    
    // é‡æ–°ç»‘å®šç‚¹å‡»äº‹ä»¶
    newActivateBtn.addEventListener('click', function(e) {
        console.log('æ¿€æ´»æŒ‰é’®è¢«ç‚¹å‡»');
        e.preventDefault();
        e.stopPropagation();
        activateApp();
    });
    
    // ç»‘å®šå›è½¦é”®äº‹ä»¶
    activationInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            e.stopPropagation();
            console.log('å›è½¦é”®æ¿€æ´»');
            activateApp();
        }
    });
    
    // è‡ªåŠ¨èšç„¦
    setTimeout(() => {
        activationInput.focus();
    }, 100);
    
    console.log('æ¿€æ´»ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ');
}

// --- Data & Configuration (291-Color MARD Palette) ---
const MARD_COLORS_FULL = {
    "A1": "#FAF4C8", "A2": "#FFFFD5", "A3": "#FEFF8B", "A4": "#FBED56", "A5": "#F4D738", "A6": "#FEAC4C", "A7": "#FE8B4C", "A8": "#FFDA45", "A9": "#FF995B", "A10": "#F77C31", "A11": "#FFDD99", "A12": "#FE9F72", "A13": "#FFC365", "A14": "#FD543D", "A15": "#FFF365", "A16": "#FFFF9F", "A17": "#FFE36E", "A18": "#FEBE7D", "A19": "#FD7C72", "A20": "#FFD568", "A21": "#FFE395", "A22": "#F4F57D", "A23": "#E6C9B7", "A24": "#F7F8A2", "A25": "#FFD67D", "A26": "#FFC830",
    "B1": "#E6EE31", "B2": "#63F347", "B3": "#9EF780", "B4": "#5DE035", "B5": "#35E352", "B6": "#65E2A6", "B7": "#3DAF80", "B8": "#1C9C4F", "B9": "#27523A", "B10": "#95D3C2", "B11": "#5D722A", "B12": "#166F41", "B13": "#CAEB7B", "B14": "#ADE946", "B15": "#2E5132", "B16": "#C5ED9C", "B17": "#9BB13A", "B18": "#E6EE49", "B19": "#24B88C", "B20": "#C2F0CC", "B21": "#156A6B", "B22": "#0B3C43", "B23": "#303A21", "B24": "#EEFCA5", "B25": "#4E846D", "B26": "#8D7A35", "B27": "#CCE1AF", "B28": "#9EE5B9", "B29": "#C5E254", "B30": "#E2FCB1", "B31": "#B0E792", "B32": "#9CAB5A",
    "C1": "#E8FFE7", "C2": "#A9F9FC", "C3": "#A0E2FB", "C4": "#41CCFF", "C5": "#01ACEB", "C6": "#50AAF0", "C7": "#3677D2", "C8": "#0F54C0", "C9": "#324BCA", "C10": "#3EBCE2", "C11": "#28DDDE", "C12": "#1C334D", "C13": "#CDE8FF", "C14": "#D5FDFF", "C15": "#22C4C6", "C16": "#1557A8", "C17": "#04D1F6", "C18": "#1D3344", "C19": "#1887A2", "C20": "#176DAF", "C21": "#BEDDFF", "C22": "#67B4BE", "C23": "#C8E2FF", "C24": "#7CC4FF", "C25": "#A9E5E5", "C26": "#3CAED8", "C27": "#D3DFFA", "C28": "#BBCFED", "C29": "#34488E",
    "D1": "#AEB4F2", "D2": "#858EDD", "D3": "#2F54AF", "D4": "#182A84", "D5": "#B843C5", "D6": "#AC7BDE", "D7": "#8854B3", "D8": "#E2D3FF", "D9": "#D5B9F8", "D10": "#361B51", "D11": "#B9BAE1", "D12": "#DE9AD4", "D13": "#B90095", "D14": "#8B279B", "D15": "#2F1F90", "D16": "#E3E1EE", "D17": "#C4D4F6", "D18": "#A45EC7", "D19": "#D8C3D7", "D20": "#9C32B2", "D21": "#9A009B", "D22": "#333A95", "D23": "#EBDAFC", "D24": "#7786E5", "D25": "#494FC7", "D26": "#DFC2F8",
    "E1": "#FDD3CC", "E2": "#FEC0DF", "E3": "#FFB7E7", "E4": "#E8649E", "E5": "#F551A2", "E6": "#F13D74", "E7": "#C63478", "E8": "#FFDBE9", "E9": "#E970CC", "E10": "#D33793", "E11": "#FCDDD2", "E12": "#F78FC3", "E13": "#B5006D", "E14": "#FFD1BA", "E15": "#F8C7C9", "E16": "#FFF3EB", "E17": "#FFE2EA", "E18": "#FFC7DB", "E19": "#FEBAD5", "E20": "#D8C7D1", "E21": "#BD9DA1", "E22": "#B785A1", "E23": "#937A8D", "E24": "#FFFF00",
    "F1": "#FD957B", "F2": "#FC3D46", "F3": "#F74941", "F4": "#FC283C", "F5": "#E7002F", "F6": "#943630", "F7": "#971937", "F8": "#BC0028", "F9": "#E2677A", "F10": "#8A4526", "F11": "#5A2121", "F12": "#FD4E6A", "F13": "#F35744", "F14": "#FFA9AD", "F15": "#D30022", "F16": "#FEC2A6", "F17": "#E69C79", "F18": "#D37C46", "F19": "#C1444A", "F20": "#CD9391", "F21": "#F7B4C6", "F22": "#FDC0D0", "F23": "#F67E66", "F24": "#E698AA", "F25": "#E54B4F",
    "G1": "#FFE2CE", "G2": "#FFC4AA", "G3": "#F4C3A5", "G4": "#E1B383", "G5": "#EDB045", "G6": "#E99C17", "G7": "#9D5B3E", "G8": "#753B32", "G9": "#E6B483", "G10": "#D98C39", "G11": "#E0C593", "G12": "#FFC890", "G13": "#B7714A", "G14": "#8D614C", "G15": "#FCF9E0", "G16": "#F2D9BA", "G17": "#7B524B", "G18": "#FFE4CC", "G19": "#E07935", "G20": "#A94023", "G21": "#B88558",
    "H1": "#FDFBFF", "H2": "#FEFFFF", "H3": "#B6B1BA", "H4": "#89858C", "H5": "#48464E", "H6": "#2F2B2F", "H7": "#000000", "H8": "#E7D6DB", "H9": "#EDEDED", "H10": "#EEE9EA", "H11": "#CECDD5", "H12": "#FFF5ED", "H13": "#F5ECD2", "H14": "#CFD7D3", "H15": "#98A6A8", "H16": "#1D1414", "H17": "#F1EDED", "H18": "#FFFDF0", "H19": "#F6EFE2", "H20": "#949FA3", "H21": "#FFFBE1", "H22": "#CACAD4", "H23": "#9A9D94",
    "M1": "#BCC6B8", "M2": "#8AA386", "M3": "#697D80", "M4": "#E3D2BC", "M5": "#D0CCAA", "M6": "#B0A782", "M7": "#B4A497", "M8": "#B38281", "M9": "#A58767", "M10": "#C5B2BC", "M11": "#9F7594", "M12": "#644749", "M13": "#D19066", "M14": "#C77362", "M15": "#757D7B",
    "P1": "#FCF7F8", "P2": "#B0A9AC", "P3": "#AFDCAB", "P4": "#FEA49F", "P5": "#EE8C3E", "P6": "#5FD0A7", "P7": "#EB9270", "P8": "#F0D958", "P9": "#D9D9D9", "P10": "#D9C7EA", "P11": "#F3ECC9", "P12": "#E6EEF2", "P13": "#AACBEF", "P14": "#3376B0", "P15": "#668575", "P16": "#FEBF45", "P17": "#FEA324", "P18": "#FEB89F", "P19": "#FFE0E9", "P20": "#FEBECF", "P21": "#ECBEBF", "P22": "#E4A89F", "P23": "#A56268",
    "Q1": "#F2A5E8", "Q2": "#E9EC91", "Q3": "#FFFF00", "Q4": "#FFEBFA", "Q5": "#76CEDE",
    "R1": "#D50D21", "R2": "#F92F83", "R3": "#FD8324", "R4": "#F8EC31", "R5": "#35C75B", "R6": "#23B891", "R7": "#19779D", "R8": "#1A60C3", "R9": "#9A56B4", "R10": "#FFDB4C", "R11": "#FFEBFA", "R12": "#D8D5CE", "R13": "#55514C", "R14": "#9FE4DF", "R15": "#77CEE9", "R16": "#3ECFCA", "R17": "#4A867A", "R18": "#7FCD9D", "R19": "#CDE55D", "R20": "#E8C7B4", "R21": "#AD6F3C", "R22": "#6C372F", "R23": "#FEB872", "R24": "#F3C1C0", "R25": "#C9675E", "R26": "#D293BE", "R27": "#EA8CB1", "R28": "#9C87D6",
    "T1": "#FFFFFF",
    "Y1": "#FD6FB4", "Y2": "#F24B94", "Y3": "#D7FAA0", "Y4": "#8BDBFA", "Y5": "#E987EA",
    "ZG1": "#DAABB3", "ZG2": "#D6AA87", "ZG3": "#C1BD8D", "ZG4": "#96B69F", "ZG5": "#849DC6", "ZG6": "#94BFE2", "ZG7": "#E2A9D2", "ZG8": "#AB91C0"
};

// Background colors to be removed
const BACKGROUND_COLOR_KEYS = ['T1', 'H1', 'H2'];

const ALL_COLOR_KEYS = Object.keys(MARD_COLORS_FULL);

const COLOR_PRESETS = {
    'å…¥é—¨10è‰²': ['H7', 'A6', 'B1', 'C3', 'D6', 'E3', 'F5', 'G1', 'H17', 'R1'],
    'æ ‡å‡†20è‰²': ['H7', 'A6', 'B1', 'C3', 'D6', 'E3', 'F5', 'G1', 'H17', 'R1', 'A13', 'B5', 'C5', 'D9', 'E9', 'F13', 'P1', 'Y1', 'Y4'],
    'è¿›é˜¶30è‰²': ['H7', 'A6', 'B1', 'C3', 'D6', 'E3', 'F5', 'G1', 'H17', 'R1', 'A13', 'B5', 'C5', 'D9', 'E9', 'F13', 'P1', 'Y1', 'Y4', 'A1','B2','C4','D7','E2','F4','G2','M1','R2'],
    'ä¸“ä¸š50è‰²': ['H7', 'A6', 'B1', 'C3', 'D6', 'E3', 'F5', 'G1', 'H17', 'R1', 'A13', 'B5', 'C5', 'D9', 'E9', 'F13', 'P1', 'Y1', 'Y4', 'A1','B2','C4','D7','E2','F4','G2','M1','R2', 'A2','B3','C6','D8','E4','F6','G3','M2','R3','P2','A3','B4','C7','D9','E5','F7','G4','M3','R4','P4'],
    'å¤§å¸ˆ100è‰²': Array.from({length: 100}, (_, i) => ALL_COLOR_KEYS[i % ALL_COLOR_KEYS.length]),
    'å…¨è‰²ç³»291è‰²': ALL_COLOR_KEYS
};

// --- State Management ---
let state = {
    originalImage: null,
    activePalette: COLOR_PRESETS['å…¨è‰²ç³»291è‰²'],
    customPalette: new Set(),
    excludedColors: new Set(),
    colorData: [], // 2D array of color codes
    initialMappedData: [], // Initial mapping data
    mergedData: [], // Data after region merging
    externalBackground: [], // Background cells marked as external
    colorCounts: {},
    highlightedColor: null,
    hiddenColors: new Set(),
    selectedColor: null,
    selectedCell: null, // {x, y, color} for color replacement
    zoomLevel: 100,
    showGrid: true,
    showCoords: true,
    showColors: true,
    showBackground: true,
    similarityThreshold: 30,
    granularity: 64,
    processingMode: 'æœªå¤„ç†',
    mergedRegions: 0,
    backgroundRemoved: 'æœªæ‰§è¡Œ',
    isEditMode: false,
    isReplaceMode: false, // é¢œè‰²æ›´æ¢åŠŸèƒ½å¼€å…³çŠ¶æ€
    isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
    // æ–°å¢ï¼šç¦ç”¨é¢„è§ˆæ ¼å­è‰²å·æ¡†çš„å¼€å…³
    disablePreview: false,
    // æ‹–æ‹½çŠ¶æ€
    isDragging: false,
    dragStart: { x: 0, y: 0 },
    dragOffset: { x: 0, y: 0 },
    canvasTransform: { x: 0, y: 0, scale: 1 },
    // CanvasçŠ¶æ€
    canvas: null,
    ctx: null,
    cellSize: 25,
    actualWidth: 0,
    actualHeight: 0,
    minX: 0,
    minY: 0,
    maxX: 0,
    maxY: 0,
    // æ–°å¢ï¼šæ™ºèƒ½çŠ¶æ€ç®¡ç†
    viewportState: {
        scrollLeft: 0,
        scrollTop: 0,
        zoomLevel: 100,
        containerWidth: 0,
        containerHeight: 0
    },
    // æ–°å¢ï¼šç¼©æ”¾çŠ¶æ€æŒä¹…åŒ–
    zoomState: {
        level: 100,
        min: 10,
        max: 500,
        step: 10
    }
};

// --- Core Algorithms ---

// Euclidean distance between two RGB colors
const getDistance = (c1, c2) => {
    return Math.sqrt((c1.r - c2.r) ** 2 + (c1.g - c2.g) ** 2 + (c1.b - c2.b) ** 2);
};

// Find dominant color in a region using improved sampling
const findDominantColor = (imageData, startX, startY, width, height, imageWidth) => {
    const colorCount = {};
    let totalPixels = 0;
    
    for (let y = startY; y < startY + height; y++) {
        for (let x = startX; x < startX + width; x++) {
            if (x >= imageWidth || y * imageWidth + x >= imageData.length / 4) continue;
            
            const i = (y * imageWidth + x) * 4;
            const r = imageData[i];
            const g = imageData[i + 1];
            const b = imageData[i + 2];
            const a = imageData[i + 3];
            
            // Skip transparent/semi-transparent pixels
            if (a < 128) continue;
            
            totalPixels++;
            
            // Create color key with some quantization to group similar colors
            const qr = Math.round(r / 8) * 8;
            const qg = Math.round(g / 8) * 8;
            const qb = Math.round(b / 8) * 8;
            const key = `${qr},${qg},${qb}`;
            colorCount[key] = (colorCount[key] || 0) + 1;
        }
    }
    
    // If no valid pixels, return null
    if (totalPixels === 0) return null;
    
    // Find color with maximum frequency
    let maxCount = 0;
    let dominantColorKey = null;
    
    for (const [colorKey, count] of Object.entries(colorCount)) {
        if (count > maxCount) {
            maxCount = count;
            dominantColorKey = colorKey;
        }
    }
    
    if (dominantColorKey) {
        const [r, g, b] = dominantColorKey.split(',').map(Number);
        return { r, g, b };
    }
    
    return null;
};

// Find closest color in palette
const findClosestColor = (targetRgb, palette) => {
    if (!targetRgb || palette.length === 0) return null;
    
    let minDistance = Infinity;
    let closestColor = null;
    
    for (const colorKey of palette) {
        const color = MARD_COLORS_FULL[colorKey];
        const rgb = hexToRgb(color);
        const distance = getDistance(targetRgb, rgb);
        
        if (distance < minDistance) {
            minDistance = distance;
            closestColor = colorKey;
        }
    }
    
    return closestColor;
};

// Hex to RGB conversion
const hexToRgb = (hex) => {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
};

// Convert numeric coordinates
const toAlphaCoord = (x, y) => {
    return `${x + 1},${y + 1}`;
};

// BFS for region merging
const mergeSimilarRegions = (data, width, height, threshold) => {
    const visited = Array(height).fill(null).map(() => Array(width).fill(false));
    const result = data.map(row => [...row]);
    const regions = [];
    let regionCount = 0;
    
    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
    
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            if (visited[y][x]) continue;
            
            const currentColor = data[y][x];
            const region = [];
            const queue = [[x, y]];
            visited[y][x] = true;
            
            // BFS to find connected region
            while (queue.length > 0) {
                const [cx, cy] = queue.shift();
                region.push([cx, cy]);
                
                for (const [dx, dy] of directions) {
                    const nx = cx + dx;
                    const ny = cy + dy;
                    
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height && 
                        !visited[ny][nx] && data[ny][nx] === currentColor) {
                        visited[ny][nx] = true;
                        queue.push([nx, ny]);
                    }
                }
            }
            
            // If region is small enough, merge with surrounding colors
            if (region.length > 1) {
                regionCount++;
                
                // Check similarity with adjacent regions
                const adjacentColors = {};
                
                for (const [cx, cy] of region) {
                    for (const [dx, dy] of directions) {
                        const nx = cx + dx;
                        const ny = cy + dy;
                        
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            const adjacentColor = data[ny][nx];
                            if (adjacentColor !== currentColor) {
                                const color1 = hexToRgb(MARD_COLORS_FULL[currentColor]);
                                const color2 = hexToRgb(MARD_COLORS_FULL[adjacentColor]);
                                const distance = getDistance(color1, color2);
                                
                                if (distance < threshold) {
                                    adjacentColors[adjacentColor] = (adjacentColors[adjacentColor] || 0) + 1;
                                }
                            }
                        }
                    }
                }
                
                // Find most similar adjacent color
                let maxAdjacency = 0;
                let dominantAdjacentColor = currentColor;
                
                for (const [color, count] of Object.entries(adjacentColors)) {
                    if (count > maxAdjacency) {
                        maxAdjacency = count;
                        dominantAdjacentColor = color;
                    }
                }
                
                // Merge if similar enough
                if (dominantAdjacentColor !== currentColor && maxAdjacency > 0) {
                    for (const [cx, cy] of region) {
                        result[cy][cx] = dominantAdjacentColor;
                    }
                }
            }
        }
    }
    
    return { result, regionCount };
};

// Flood fill for background removal
const removeBackground = (data, width, height) => {
    const isExternal = Array(height).fill(null).map(() => Array(width).fill(false));
    const visited = Array(height).fill(null).map(() => Array(width).fill(false));
    
    // Start from all boundary cells
    const queue = [];
    
    // Add all boundary cells
    for (let x = 0; x < width; x++) {
        queue.push([x, 0]);
        queue.push([x, height - 1]);
    }
    for (let y = 1; y < height - 1; y++) {
        queue.push([0, y]);
        queue.push([width - 1, y]);
    }
    
    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
    
    while (queue.length > 0) {
        const [cx, cy] = queue.shift();
        
        if (visited[cy][cx]) continue;
        visited[cy][cx] = true;
        
        const color = data[cy][cx];
        
        // Check if this is a background color
        if (BACKGROUND_COLOR_KEYS.includes(color)) {
            isExternal[cy][cx] = true;
            
            // Add adjacent cells to queue
            for (const [dx, dy] of directions) {
                const nx = cx + dx;
                const ny = cy + dy;
                
                if (nx >= 0 && nx < width && ny >= 0 && ny < height && !visited[ny][nx]) {
                    queue.push([nx, ny]);
                }
            }
        }
    }
    
    return isExternal;
};

// Remap excluded colors
const remapExcludedColors = (data, excludedColors, availableColors) => {
    if (excludedColors.size === 0) return data;
    
    const result = data.map(row => [...row]);
    
    for (const excludedColor of excludedColors) {
        const targetPalette = availableColors.filter(color => !excludedColors.has(color));
        
        if (targetPalette.length === 0) {
            console.warn('No available colors after exclusion');
            continue;
        }
        
        for (let y = 0; y < result.length; y++) {
            for (let x = 0; x < result[y].length; x++) {
                if (result[y][x] === excludedColor) {
                    // Find closest color from target palette
                    const excludedRgb = hexToRgb(MARD_COLORS_FULL[excludedColor]);
                    const newColor = findClosestColor(excludedRgb, targetPalette);
                    if (newColor) {
                        result[y][x] = newColor;
                    }
                }
            }
        }
    }
    
    return result;
};

// --- Main Processing Pipeline ---

// Step 1: Initial Color Mapping with Max Pooling
const performInitialMapping = (imageData, width, height, imageWidth, imageHeight) => {
    const cellWidth = Math.floor(imageWidth / width);
    const cellHeight = Math.floor(imageHeight / height);
    const mappedData = [];
    
    console.log(`å¼€å§‹åˆå§‹æ˜ å°„: ${width}x${height}, å•å…ƒæ ¼å¤§å°: ${cellWidth}x${cellHeight}`);
    
    for (let y = 0; y < height; y++) {
        const row = [];
        const startY = Math.floor(y * cellHeight);
        
        for (let x = 0; x < width; x++) {
            const startX = Math.floor(x * cellWidth);
            
            // Find dominant color in this cell
            const dominantColor = findDominantColor(
                imageData, startX, startY, 
                cellWidth, cellHeight, imageWidth
            );
            
            if (dominantColor) {
                // Map to closest color in active palette
                const colorKey = findClosestColor(dominantColor, state.activePalette);
                if (colorKey) {
                    row.push(colorKey);
                } else {
                    // Use first available color as fallback
                    row.push(state.activePalette[0]);
                }
            } else {
                // Use first available color as fallback
                row.push(state.activePalette[0]);
            }
        }
        mappedData.push(row);
    }
    
    console.log('åˆå§‹æ˜ å°„å®Œæˆï¼Œæ˜ å°„æ•°æ®è¡Œæ•°:', mappedData.length);
    return mappedData;
};

// Step 2: Region Color Merging
const performRegionMerging = (data) => {
    const { result, regionCount } = mergeSimilarRegions(
        data, data[0].length, data.length, state.similarityThreshold
    );
    
    state.processingMode = 'åŒºåŸŸåˆå¹¶';
    state.mergedRegions = regionCount;
    updateStatus();
    
    console.log(`åŒºåŸŸåˆå¹¶å®Œæˆï¼Œåˆå¹¶äº† ${regionCount} ä¸ªåŒºåŸŸ`);
    return result;
};

// Step 3: Background Removal
const performBackgroundRemoval = (data) => {
    const isExternal = removeBackground(data, data[0].length, data.length);
    
    state.processingMode = 'èƒŒæ™¯ç§»é™¤';
    state.backgroundRemoved = `${isExternal.flat().filter(x => x).length}ä¸ªå•å…ƒæ ¼`;
    updateStatus();
    
    console.log(`èƒŒæ™¯ç§»é™¤å®Œæˆï¼Œæ ‡è®°äº† ${isExternal.flat().filter(x => x).length} ä¸ªèƒŒæ™¯å•å…ƒæ ¼`);
    return isExternal;
};

// Step 4: Color Exclusion and Remapping
const performColorExclusion = (data, excludedColors) => {
    if (excludedColors.size === 0) return data;
    
    const availableColors = state.activePalette.filter(color => !excludedColors.has(color));
    console.log(`é¢œè‰²æ’é™¤å¤„ç†ï¼Œæ’é™¤é¢œè‰²æ•°: ${excludedColors.size}, å¯ç”¨é¢œè‰²æ•°: ${availableColors.length}`);
    return remapExcludedColors(data, excludedColors, availableColors);
};

// Complete processing pipeline
const processImage = async () => {
    if (!state.originalImage) {
        alert("è¯·å…ˆä¸Šä¼ å›¾ç‰‡ï¼");
        return;
    }
    
    console.log('å¼€å§‹å¤„ç†å›¾ç‰‡...');
    
    // Show progress
    const progressContainer = document.getElementById('progress-container');
    const progressFill = document.getElementById('progress-fill');
    const progressText = document.getElementById('progress-text');
    
    progressContainer.style.display = 'block';
    progressFill.style.width = '0%';
    progressText.textContent = 'åˆå§‹åŒ–...';
    
    try {
        // Create canvas for image data
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        const width = parseInt(document.getElementById('width-input').value);
        const height = parseInt(document.getElementById('height-input').value);
        
        // Set canvas to actual image dimensions for processing
        canvas.width = state.originalImage.width;
        canvas.height = state.originalImage.height;
        ctx.drawImage(state.originalImage, 0, 0);
        
        const fullImageData = ctx.getImageData(0, 0, state.originalImage.width, state.originalImage.height);
        
        // Step 1: Initial Mapping
        progressFill.style.width = '25%';
        progressText.textContent = 'æ­¥éª¤1: åˆå§‹é¢œè‰²æ˜ å°„...';
        state.initialMappedData = performInitialMapping(
            fullImageData.data, width, height, 
            state.originalImage.width, state.originalImage.height
        );
        
        // Step 2: Region Merging
        progressFill.style.width = '50%';
        progressText.textContent = 'æ­¥éª¤2: åŒºåŸŸé¢œè‰²åˆå¹¶...';
        state.mergedData = performRegionMerging(state.initialMappedData);
        
        // Step 3: Background Removal
        progressFill.style.width = '75%';
        progressText.textContent = 'æ­¥éª¤3: èƒŒæ™¯ç§»é™¤...';
        state.externalBackground = performBackgroundRemoval(state.mergedData);
        
        // Step 4: Color Exclusion
        progressFill.style.width = '90%';
        progressText.textContent = 'æ­¥éª¤4: é¢œè‰²æ’é™¤å¤„ç†...';
        state.colorData = performColorExclusion(state.mergedData, state.excludedColors);
        
        // Update color counts
        state.colorCounts = {};
        for (let y = 0; y < state.colorData.length; y++) {
            for (let x = 0; x < state.colorData[y].length; x++) {
                if (!state.externalBackground[y][x]) {
                    const key = state.colorData[y][x];
                    state.colorCounts[key] = (state.colorCounts[key] || 0) + 1;
                }
            }
        }
        
        progressFill.style.width = '100%';
        progressText.textContent = 'å®Œæˆï¼';
        
        console.log('å›¾ç‰‡å¤„ç†å®Œæˆï¼Œé¢œè‰²ç»Ÿè®¡:', state.colorCounts);
        
        setTimeout(() => {
            progressContainer.style.display = 'none';
        }, 1000);
        
        renderCanvas();
        renderShoppingList();
        
    } catch (error) {
        console.error('Processing error:', error);
        progressText.textContent = 'å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•';
        setTimeout(() => {
            progressContainer.style.display = 'none';
        }, 2000);
    }
};

// --- Rendering Functions ---

// ä¿®å¤ï¼šå…¨æ–°çš„å›¾çº¸é¢„è§ˆæ¸²æŸ“å‡½æ•° - è§£å†³ç¼©æ”¾å’Œæ˜¾ç¤ºé—®é¢˜
const renderCanvas = (isEditMode = false, preserveZoom = false) => {
    if (!state.colorData || state.colorData.length === 0) {
        console.log('æ²¡æœ‰é¢œè‰²æ•°æ®å¯ä»¥æ¸²æŸ“');
        return;
    }
    
    // ä¿å­˜å½“å‰è§†å£çŠ¶æ€
    let viewportState = null;
    if (preserveZoom) {
        const viewport = document.getElementById(isEditMode ? 'edit-canvas-viewport' : 'canvas-viewport');
        if (viewport) {
            viewportState = {
                scrollLeft: viewport.scrollLeft,
                scrollTop: viewport.scrollTop,
                width: viewport.style.width,
                height: viewport.style.height
            };
            console.log('ä¿å­˜è§†å£çŠ¶æ€:', viewportState);
        }
    }
    
    // è®¡ç®—å®é™…å†…å®¹è¾¹ç•Œ - ä¼˜åŒ–è¾¹ç•Œè®¡ç®—å‡å°‘ç©ºç™½
    state.minX = state.colorData[0].length;
    state.maxX = 0;
    state.minY = state.colorData.length;
    state.maxY = 0;
    let hasContent = false;
    
    for(let y = 0; y < state.colorData.length; y++) {
        for(let x = 0; x < state.colorData[y].length; x++) {
            const key = state.colorData[y][x];
            if (!key) continue;
            
            // åªæœ‰éèƒŒæ™¯ä¸”ééšè—çš„é¢œè‰²è®¡å…¥è¾¹ç•Œ
            if (!(state.externalBackground[y] && state.externalBackground[y][x]) && 
                !state.hiddenColors.has(key)) {
                hasContent = true;
                state.minX = Math.min(state.minX, x);
                state.maxX = Math.max(state.maxX, x);
                state.minY = Math.min(state.minY, y);
                state.maxY = Math.max(state.maxY, y);
            }
        }
    }
    
    // å¦‚æœæ²¡æœ‰å†…å®¹ï¼Œä½¿ç”¨é»˜è®¤å€¼
    if (!hasContent) {
        state.minX = 0;
        state.minY = 0;
        state.maxX = Math.min(10, state.colorData[0].length - 1);
        state.maxY = Math.min(10, state.colorData.length - 1);
    } else {
        // å‡å°‘ä¸å¿…è¦çš„è¾¹ç•Œæ‰©å±• - åªåœ¨è¾¹ç•Œä¸æ˜¯è¾¹ç¼˜æ—¶æ‰æ‰©å±•
        if (state.minX > 0) state.minX = Math.max(0, state.minX);
        if (state.minY > 0) state.minY = Math.max(0, state.minY);
        if (state.maxX < state.colorData[0].length - 1) state.maxX = Math.min(state.colorData[0].length - 1, state.maxX);
        if (state.maxY < state.colorData.length - 1) state.maxY = Math.min(state.colorData.length - 1, state.maxY);
    }
    
    state.actualWidth = state.maxX - state.minX + 1;
    state.actualHeight = state.maxY - state.minY + 1;
    
    // ä½¿ç”¨å›ºå®šå•å…ƒæ ¼å¤§å°ï¼Œä¸éšç¼©æ”¾å˜åŒ–
    const baseCellSize = 25;
    const scale = state.zoomLevel / 100;
    
    // å‡å°‘åæ ‡å’Œå†…è¾¹è·å ç”¨ç©ºé—´
    const coordSize = state.showCoords ? 30 : 10;
    const padding = state.showCoords ? 40 : 15;
    
    // åˆ›å»ºç”»å¸ƒ
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.id = 'pattern-canvas';
    
    // ä½¿ç”¨åŸºç¡€å•å…ƒæ ¼å¤§å°è®¡ç®—ç”»å¸ƒå°ºå¯¸ï¼Œç¡®ä¿å†…å®¹å®Œæ•´
    canvas.width = state.actualWidth * baseCellSize + padding;
    canvas.height = state.actualHeight * baseCellSize + padding;
    
    // ä¿å­˜ç”»å¸ƒå¼•ç”¨
    state.canvas = canvas;
    state.ctx = ctx;
    
    ctx.imageSmoothingEnabled = false;
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // ç»˜åˆ¶åæ ‡æ ‡ç­¾ - å‡å°å­—ä½“å’Œé—´è·
    if (state.showCoords) {
        ctx.font = `bold 12px Arial`; 
        ctx.textAlign = 'center'; 
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#333';
        
        for(let x = state.minX; x <= state.maxX; x++) {
            const label = (x + 1).toString();
            const xPos = (x - state.minX) * baseCellSize + baseCellSize/2 + padding/2;
            ctx.fillText(label, xPos, padding/2 - 10);
        }
        
        for(let y = state.minY; y <= state.maxY; y++) {
            const label = (y + 1).toString();
            const yPos = (y - state.minY) * baseCellSize + baseCellSize/2 + padding/2;
            ctx.fillText(label, padding/2 - 10, yPos);
        }
    }

    // ç»˜åˆ¶ç½‘æ ¼å’Œç å­
    const offsetX = state.showCoords ? padding/2 : 10;
    const offsetY = state.showCoords ? padding/2 : 10;
    
    for(let y = state.minY; y <= state.maxY; y++) {
        for(let x = state.minX; x <= state.maxX; x++) {
            const key = state.colorData[y][x];
            if (!key) continue;
            
            // ä½¿ç”¨åŸºç¡€å•å…ƒæ ¼å¤§å°è®¡ç®—ä½ç½®
            const px = (x - state.minX) * baseCellSize + offsetX;
            const py = (y - state.minY) * baseCellSize + offsetY;
            
            // è·³è¿‡éšè—çš„é¢œè‰²
            if (state.hiddenColors.has(key)) {
                ctx.fillStyle = '#f8f8f8';
                ctx.fillRect(px, py, baseCellSize, baseCellSize);
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 1;
                ctx.strokeRect(px, py, baseCellSize, baseCellSize);
                continue;
            }
            
            // è·³è¿‡å¤–éƒ¨èƒŒæ™¯ï¼ˆå¦‚æœä¸æ˜¾ç¤ºèƒŒæ™¯ï¼‰
            if (!state.showBackground && state.externalBackground[y] && state.externalBackground[y][x]) {
                continue;
            }
            
            // ç»˜åˆ¶ç å­
            if (state.externalBackground[y] && state.externalBackground[y][x]) {
                ctx.fillStyle = '#f0f0f0';
            } else {
                ctx.fillStyle = MARD_COLORS_FULL[key];
            }
            ctx.fillRect(px, py, baseCellSize, baseCellSize);
            
            // ç»˜åˆ¶ç½‘æ ¼
            if (state.showGrid) {
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.strokeRect(px, py, baseCellSize, baseCellSize);
            }
            
            // é«˜äº®ç›¸åŒé¢œè‰²
            if (state.highlightedColor === key) {
                ctx.fillStyle = 'rgba(255, 200, 0, 0.4)';
                ctx.fillRect(px, py, baseCellSize, baseCellSize);
                ctx.strokeStyle = '#ff9500';
                ctx.lineWidth = 3;
                ctx.strokeRect(px, py, baseCellSize, baseCellSize);
                ctx.lineWidth = 1;
            }
            
            // ç»˜åˆ¶è‰²å·
            if (state.showColors && !(state.externalBackground[y] && state.externalBackground[y][x])) {
                const rgb = hexToRgb(MARD_COLORS_FULL[key]);
                const brightness = (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
                ctx.fillStyle = brightness > 140 ? '#000' : '#fff';
                
                const fontSize = Math.min(baseCellSize * 0.4, 18);
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center'; 
                ctx.textBaseline = 'middle';
                
                const text = key;
                ctx.fillText(text, px + baseCellSize/2, py + baseCellSize/2);
            }
        }
    }
    
    // è®¾ç½®ç›®æ ‡åŒºåŸŸ
    const targetSection = isEditMode ? 
        document.getElementById('edit-mode-canvas-container') : 
        document.getElementById('canvas-section');
    
    // ä¿®å¤ï¼šä¿å­˜åŸæœ‰çš„ç¼©æ”¾æ§ä»¶çŠ¶æ€
    let zoomValue = null;
    if (preserveZoom) {
        const existingZoomValue = document.getElementById(isEditMode ? 'edit-zoom-value' : 'zoom-value');
        if (existingZoomValue) {
            zoomValue = existingZoomValue.textContent;
        }
    }
    
    targetSection.innerHTML = ''; 
    
    // åˆ›å»ºæ§åˆ¶æ 
    const controlsDiv = document.createElement('div');
    controlsDiv.className = 'canvas-controls';
    
    // ç¼©æ”¾æ§åˆ¶
    const zoomControls = document.createElement('div');
    zoomControls.className = 'zoom-controls';
    
    const zoomOutBtn = document.createElement('button');
    zoomOutBtn.className = 'zoom-btn';
    zoomOutBtn.textContent = 'ï¼';
    zoomOutBtn.onclick = () => {
        state.zoomLevel = Math.max(state.zoomState.min, state.zoomLevel - state.zoomState.step);
        updateZoomDisplay();
        applyZoom();
    };
    
    const zoomValueSpan = document.createElement('span');
    zoomValueSpan.className = 'zoom-value';
    zoomValueSpan.id = isEditMode ? 'edit-zoom-value' : 'zoom-value';
    // æ¢å¤ç¼©æ”¾å€¼æ˜¾ç¤º
    zoomValueSpan.textContent = zoomValue || (state.zoomLevel + '%');
    
    const zoomInBtn = document.createElement('button');
    zoomInBtn.className = 'zoom-btn';
    zoomInBtn.textContent = 'ï¼‹';
    zoomInBtn.onclick = () => {
        state.zoomLevel = Math.min(state.zoomState.max, state.zoomLevel + state.zoomState.step);
        updateZoomDisplay();
        applyZoom();
    };
    
    const zoomResetBtn = document.createElement('button');
    zoomResetBtn.className = 'zoom-btn';
    zoomResetBtn.textContent = 'âŸ²';
    zoomResetBtn.onclick = () => {
        state.zoomLevel = 100;
        updateZoomDisplay();
        applyZoom();
    };
    
    zoomControls.appendChild(zoomOutBtn);
    zoomControls.appendChild(zoomValueSpan);
    zoomControls.appendChild(zoomInBtn);
    zoomControls.appendChild(zoomResetBtn);
    
    controlsDiv.appendChild(zoomControls);
    targetSection.appendChild(controlsDiv);
    
    // åˆ›å»ºè§†å£å®¹å™¨ - ä¿®å¤å…³é”®é—®é¢˜
    const viewport = document.createElement('div');
    viewport.className = 'canvas-viewport';
    viewport.id = isEditMode ? 'edit-canvas-viewport' : 'canvas-viewport';
    
    // åˆ›å»ºå†…å®¹å®¹å™¨
    const content = document.createElement('div');
    content.className = 'canvas-content';
    content.id = isEditMode ? 'edit-canvas-content' : 'canvas-content';
    
    // æ·»åŠ ç”»å¸ƒåˆ°å†…å®¹å®¹å™¨
    content.appendChild(canvas);
    
    // æ·»åŠ å†…å®¹å®¹å™¨åˆ°è§†å£
    viewport.appendChild(content);
    
    // æ·»åŠ è§†å£åˆ°ç›®æ ‡åŒºåŸŸ
    targetSection.appendChild(viewport);
    
    // ä¿®å¤ï¼šåº”ç”¨ç¼©æ”¾å‡½æ•° - è§£å†³ç¼©æ”¾å’Œæ‹–æ‹½é—®é¢˜
    function applyZoom() {
        const viewport = document.getElementById(isEditMode ? 'edit-canvas-viewport' : 'canvas-viewport');
        const content = viewport?.querySelector('.canvas-content');
        if (!viewport || !content || !state.canvas) return;
        
        const scale = state.zoomLevel / 100;
        
        // è®¾ç½®å†…å®¹å°ºå¯¸ä¸ºåŸå§‹ç”»å¸ƒå°ºå¯¸
        content.style.width = `${state.canvas.width}px`;
        content.style.height = `${state.canvas.height}px`;
        
        // åº”ç”¨ç¼©æ”¾å˜æ¢
        content.style.transform = `scale(${scale})`;
        content.style.transformOrigin = '0 0';
        
        // ä¿®å¤ï¼šå…³é”® - è®¡ç®—ç¼©æ”¾åçš„å®é™…å†…å®¹å°ºå¯¸
        const scaledWidth = state.canvas.width * scale;
        const scaledHeight = state.canvas.height * scale;
        
        // ä¿®å¤ï¼šå…³é”® - è§†å£å°ºå¯¸åº”è¯¥åŸºäºå®¹å™¨å¤§å°ï¼Œè€Œä¸æ˜¯ç¼©æ”¾åçš„å†…å®¹
        const containerRect = viewport.parentElement.getBoundingClientRect();
        const maxViewportWidth = containerRect.width - 40; // å‡å»padding
        const maxViewportHeight = Math.min(600, window.innerHeight * 0.6); // é™åˆ¶æœ€å¤§é«˜åº¦
        
        // ä¿®å¤ï¼šå…³é”® - è§†å£å°ºå¯¸åº”è¯¥æ˜¯å®¹å™¨é™åˆ¶å’Œç¼©æ”¾å†…å®¹å°ºå¯¸çš„è¾ƒå°å€¼
        const viewportWidth = Math.min(maxViewportWidth, Math.max(scaledWidth + 40, 300));
        const viewportHeight = Math.min(maxViewportHeight, Math.max(scaledHeight + 40, 400));
        
        // åº”ç”¨è§†å£å°ºå¯¸
        viewport.style.width = `${viewportWidth}px`;
        viewport.style.height = `${viewportHeight}px`;
        
        // ä¿®å¤ï¼šå…³é”® - ç¡®ä¿æ»šåŠ¨æ¡æ­£ç¡®æ˜¾ç¤º
        if (scaledWidth > viewportWidth - 40 || scaledHeight > viewportHeight - 40) {
            viewport.style.overflow = 'auto';
        } else {
            viewport.style.overflow = 'hidden';
        }
        
        // æ¢å¤è§†å£çŠ¶æ€
        if (preserveZoom && viewportState) {
            // ä½¿ç”¨setTimeoutç¡®ä¿DOMæ›´æ–°åå†æ¢å¤æ»šåŠ¨ä½ç½®
            setTimeout(() => {
                viewport.scrollLeft = viewportState.scrollLeft;
                viewport.scrollTop = viewportState.scrollTop;
                console.log('æ¢å¤è§†å£çŠ¶æ€:', viewportState.scrollLeft, viewportState.scrollTop);
            }, 10);
        }
        
        console.log(`ç¼©æ”¾åº”ç”¨: ${state.zoomLevel}%, è§†å£: ${viewportWidth}x${viewportHeight}, å†…å®¹: ${scaledWidth}x${scaledHeight}`);
    }
    
    // æ›´æ–°ç¼©æ”¾æ˜¾ç¤º
    function updateZoomDisplay() {
        zoomValueSpan.textContent = state.zoomLevel + '%';
    }
    
    // ä¿®å¤ï¼šåªåœ¨ä¸éœ€è¦ä¿æŒç¼©æ”¾æ—¶åº”ç”¨ç¼©æ”¾
    if (!preserveZoom) {
        applyZoom();
    } else {
        // ä¿æŒå½“å‰ç¼©æ”¾çŠ¶æ€ï¼Œåªæ›´æ–°ç”»å¸ƒå†…å®¹
        const scale = state.zoomLevel / 100;
        
        // è®¾ç½®å†…å®¹å°ºå¯¸ä¸ºåŸå§‹ç”»å¸ƒå°ºå¯¸
        content.style.width = `${state.canvas.width}px`;
        content.style.height = `${state.canvas.height}px`;
        
        // åº”ç”¨ç¼©æ”¾å˜æ¢
        content.style.transform = `scale(${scale})`;
        content.style.transformOrigin = '0 0';
        
        // è®¡ç®—ç¼©æ”¾åçš„å®é™…å†…å®¹å°ºå¯¸
        const scaledWidth = state.canvas.width * scale;
        const scaledHeight = state.canvas.height * scale;
        
        // è§†å£å°ºå¯¸åº”è¯¥åŸºäºå®¹å™¨å¤§å°
        const containerRect = viewport.parentElement.getBoundingClientRect();
        const maxViewportWidth = containerRect.width - 40;
        const maxViewportHeight = Math.min(600, window.innerHeight * 0.6);
        
        // è§†å£å°ºå¯¸åº”è¯¥æ˜¯å®¹å™¨é™åˆ¶å’Œç¼©æ”¾å†…å®¹å°ºå¯¸çš„è¾ƒå°å€¼
        const viewportWidth = Math.min(maxViewportWidth, Math.max(scaledWidth + 40, 300));
        const viewportHeight = Math.min(maxViewportHeight, Math.max(scaledHeight + 40, 400));
        
        // åº”ç”¨è§†å£å°ºå¯¸
        viewport.style.width = `${viewportWidth}px`;
        viewport.style.height = `${viewportHeight}px`;
        
        // ç¡®ä¿æ»šåŠ¨æ¡æ­£ç¡®æ˜¾ç¤º
        if (scaledWidth > viewportWidth - 40 || scaledHeight > viewportHeight - 40) {
            viewport.style.overflow = 'auto';
        } else {
            viewport.style.overflow = 'hidden';
        }
        
        // æ¢å¤è§†å£çŠ¶æ€
        if (viewportState) {
            // ä½¿ç”¨setTimeoutç¡®ä¿DOMæ›´æ–°åå†æ¢å¤æ»šåŠ¨ä½ç½®
            setTimeout(() => {
                viewport.scrollLeft = viewportState.scrollLeft;
                viewport.scrollTop = viewportState.scrollTop;
                console.log('æ¢å¤è§†å£çŠ¶æ€:', viewportState.scrollLeft, viewportState.scrollTop);
            }, 10);
        }
    }
    
    // ç»‘å®šäº‹ä»¶ç›‘å¬å™¨
    attachCanvasListeners(canvas, isEditMode);
    attachViewportListeners(viewport, isEditMode);
    
    // ä¿®å¤ï¼šå…³é”® - é‡æ–°ç»‘å®šç¼–è¾‘æ¨¡å¼åŠŸèƒ½äº‹ä»¶ç›‘å¬å™¨
    if (isEditMode) {
        setTimeout(() => {
            bindEditModeEvents();
        }, 100);
    }
};

// ä¿®å¤ï¼šå…¨æ–°çš„è§†å£äº‹ä»¶ç›‘å¬å™¨ - è§£å†³ç§»åŠ¨ç«¯ç¼©æ”¾å’Œæ‹–æ‹½é—®é¢˜
const attachViewportListeners = (viewport, isEditMode = false) => {
    let isDragging = false;
    let startX, startY;
    let scrollLeft = 0;
    let scrollTop = 0;
    let initialDistance = 0;
    let initialScale = 1;
    
    // é¼ æ ‡æ»šè½®ç¼©æ”¾
    viewport.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        const currentScale = state.zoomLevel / 100;
        const newScale = Math.min(Math.max(state.zoomState.min / 100, currentScale * delta), state.zoomState.max / 100);
        state.zoomLevel = Math.round(newScale * 100);
        
        // ä¿å­˜å½“å‰æ»šåŠ¨ä½ç½®
        const x = e.clientX - viewport.getBoundingClientRect().left;
        const y = e.clientY - viewport.getBoundingClientRect().top;
        
        const scaleChange = newScale / currentScale;
        
        // è°ƒæ•´æ»šåŠ¨ä½ç½®ä»¥ä¿æŒé¼ æ ‡ä½ç½®ä¸å˜
        viewport.scrollLeft = (viewport.scrollLeft + x) * scaleChange - x;
        viewport.scrollTop = (viewport.scrollTop + y) * scaleChange - y;
        
        // åº”ç”¨ç¼©æ”¾
        const content = viewport.querySelector('.canvas-content');
        if (content) {
            const scale = state.zoomLevel / 100;
            content.style.transform = `scale(${scale})`;
            content.style.width = `${state.canvas.width}px`;
            content.style.height = `${state.canvas.height}px`;
            
            // ä¿®å¤ï¼šåŠ¨æ€è°ƒæ•´è§†å£å°ºå¯¸
            const scaledWidth = state.canvas.width * scale;
            const scaledHeight = state.canvas.height * scale;
            viewport.style.width = `${Math.max(scaledWidth + 40, 300)}px`;
            viewport.style.height = `${Math.max(scaledHeight + 40, 400)}px`;
        }
        
        // æ›´æ–°ç¼©æ”¾æ˜¾ç¤º
        const zoomValue = document.getElementById(isEditMode ? 'edit-zoom-value' : 'zoom-value');
        if (zoomValue) {
            zoomValue.textContent = state.zoomLevel + '%';
        }
    });
    
    // é¼ æ ‡æ‹–æ‹½ - ä¿®å¤ï¼šç¡®ä¿ç‚¹å‡»å›¾çº¸ä¹Ÿèƒ½æ‹–æ‹½
    viewport.addEventListener('mousedown', (e) => {
        // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»åœ¨canvasä¸Šæˆ–è€…é¢œè‰²æ›´æ¢æ¨¡å¼
        const clickedOnCanvas = e.target.dataset.isCanvas === 'true' || 
                                e.target.closest('#pattern-canvas');
        
        if (state.isReplaceMode && clickedOnCanvas) {
            // é¢œè‰²æ›´æ¢æ¨¡å¼ä¸‹ç‚¹å‡»canvasä¸è§¦å‘æ‹–æ‹½
            return;
        }
        
        isDragging = true;
        startX = e.pageX - viewport.offsetLeft;
        startY = e.pageY - viewport.offsetTop;
        scrollLeft = viewport.scrollLeft;
        scrollTop = viewport.scrollTop;
        viewport.style.cursor = 'grabbing';
        viewport.classList.add('dragging');
        e.preventDefault();
    });
    
    viewport.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        const x = e.pageX - viewport.offsetLeft;
        const y = e.pageY - viewport.offsetTop;
        const walkX = (x - startX) * 2;
        const walkY = (y - startY) * 2;
        viewport.scrollLeft = scrollLeft - walkX;
        viewport.scrollTop = scrollTop - walkY;
    });
    
    viewport.addEventListener('mouseup', () => {
        isDragging = false;
        viewport.style.cursor = 'grab';
        viewport.classList.remove('dragging');
    });
    
    viewport.addEventListener('mouseleave', () => {
        isDragging = false;
        viewport.style.cursor = 'grab';
        viewport.classList.remove('dragging');
    });
    
    // è§¦æ‘¸äº‹ä»¶å¤„ç† - ä¿®å¤ç§»åŠ¨ç«¯ç¼©æ”¾å’Œæ‹–æ‹½
    viewport.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
            // åŒæŒ‡ç¼©æ”¾
            e.preventDefault();
            isDragging = false;
            initialDistance = getTouchDistance(e.touches);
            initialScale = state.zoomLevel / 100;
        } else if (e.touches.length === 1) {
            // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»åœ¨canvasä¸Šæˆ–è€…é¢œè‰²æ›´æ¢æ¨¡å¼
            const touch = e.touches[0];
            const element = document.elementFromPoint(touch.clientX, touch.clientY);
            const touchedOnCanvas = element && (
                element.dataset.isCanvas === 'true' || 
                element.closest('#pattern-canvas')
            );
            
            if (state.isReplaceMode && touchedOnCanvas) {
                // é¢œè‰²æ›´æ¢æ¨¡å¼ä¸‹ç‚¹å‡»canvasä¸è§¦å‘æ‹–æ‹½
                return;
            }
            
            // å•æŒ‡æ‹–æ‹½
            e.preventDefault();
            isDragging = true;
            startX = touch.pageX - viewport.offsetLeft;
            startY = touch.pageY - viewport.offsetTop;
            scrollLeft = viewport.scrollLeft;
            scrollTop = viewport.scrollTop;
        }
    }, { passive: false });
    
    viewport.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2) {
            // åŒæŒ‡ç¼©æ”¾
            e.preventDefault();
            isDragging = false;
            
            const currentDistance = getTouchDistance(e.touches);
            if (initialDistance > 0) {
                const newScale = Math.min(Math.max(state.zoomState.min / 100, initialScale * (currentDistance / initialDistance)), state.zoomState.max / 100);
                state.zoomLevel = Math.round(newScale * 100);
                
                // è®¡ç®—ç¼©æ”¾ä¸­å¿ƒç‚¹
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const centerX = (touch1.clientX + touch2.clientX) / 2;
                const centerY = (touch1.clientY + touch2.clientY) / 2;
                
                const rect = viewport.getBoundingClientRect();
                const x = centerX - rect.left;
                const y = centerY - rect.top;
                
                const scaleChange = newScale / (state.zoomLevel / 100);
                
                // è°ƒæ•´æ»šåŠ¨ä½ç½®ä»¥ä¿æŒç¼©æ”¾ä¸­å¿ƒä¸å˜
                viewport.scrollLeft = (viewport.scrollLeft + x) * scaleChange - x;
                viewport.scrollTop = (viewport.scrollTop + y) * scaleChange - y;
                
                // åº”ç”¨ç¼©æ”¾
                const content = viewport.querySelector('.canvas-content');
                if (content) {
                    const scale = state.zoomLevel / 100;
                    content.style.transform = `scale(${scale})`;
                    content.style.width = `${state.canvas.width}px`;
                    content.style.height = `${state.canvas.height}px`;
                    
                    // ä¿®å¤ï¼šåŠ¨æ€è°ƒæ•´è§†å£å°ºå¯¸
                    const scaledWidth = state.canvas.width * scale;
                    const scaledHeight = state.canvas.height * scale;
                    viewport.style.width = `${Math.max(scaledWidth + 40, 300)}px`;
                    viewport.style.height = `${Math.max(scaledHeight + 40, 400)}px`;
                }
                
                // æ›´æ–°ç¼©æ”¾æ˜¾ç¤º
                const zoomValue = document.getElementById(isEditMode ? 'edit-zoom-value' : 'zoom-value');
                if (zoomValue) {
                    zoomValue.textContent = state.zoomLevel + '%';
                }
            }
        } else if (e.touches.length === 1 && isDragging && !state.isReplaceMode) {
            // å•æŒ‡æ‹–æ‹½
            e.preventDefault();
            const touch = e.touches[0];
            const x = touch.pageX - viewport.offsetLeft;
            const y = touch.pageY - viewport.offsetTop;
            const walkX = (x - startX) * 2;
            const walkY = (y - startY) * 2;
            viewport.scrollLeft = scrollLeft - walkX;
            viewport.scrollTop = scrollTop - walkY;
        }
    }, { passive: false });
    
    viewport.addEventListener('touchend', () => {
        isDragging = false;
    });
    
    viewport.addEventListener('touchcancel', () => {
        isDragging = false;
    });
};

const getTouchDistance = (touches) => {
    const dx = touches[0].clientX - touches[1].clientX;
    const dy = touches[0].clientY - touches[1].clientY;
    return Math.sqrt(dx * dx + dy * dy);
};

// ä¿®å¤ï¼šåæ ‡è®¡ç®—å‡½æ•° - é€‚é…æ–°çš„UIç»“æ„
const getCanvasCoordinates = (canvas, event) => {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    // è·å–é¼ æ ‡åœ¨ç”»å¸ƒä¸­çš„å®é™…åæ ‡
    let clientX, clientY;
    if (event.touches && event.touches.length > 0) {
        clientX = event.touches[0].clientX;
        clientY = event.touches[0].clientY;
    } else if (event.changedTouches && event.changedTouches.length > 0) {
        clientX = event.changedTouches[0].clientX;
        clientY = event.changedTouches[0].clientY;
    } else {
        clientX = event.clientX;
        clientY = event.clientY;
    }
    
    // è®¡ç®—ç›¸å¯¹äºç”»å¸ƒçš„åæ ‡ï¼Œè€ƒè™‘ç¼©æ”¾
    const canvasX = (clientX - rect.left) * scaleX;
    const canvasY = (clientY - rect.top) * scaleY;
    
    // ä½¿ç”¨åŸºç¡€cellSizeè®¡ç®—æ ¼å­åæ ‡
    const baseCellSize = 25; // åŸºç¡€å•å…ƒæ ¼å¤§å°ï¼Œä¸éšç¼©æ”¾å˜åŒ–
    
    // è®¡ç®—æ ¼å­åæ ‡ï¼Œä½¿ç”¨åŸºç¡€cellSize
    const coordX = Math.floor((canvasX - 20) / baseCellSize) + state.minX;
    const coordY = Math.floor((canvasY - 20) / baseCellSize) + state.minY;
    
    return { x: coordX, y: coordY, canvasX, canvasY };
};

// ä¼˜åŒ–çš„äº‹ä»¶ç›‘å¬å™¨ - ç§»é™¤éé¢œè‰²æ›´æ¢æ¨¡å¼ä¸‹çš„ç‚¹å‡»é€‰æ‹©é¢œè‰²åŠŸèƒ½
const attachCanvasListeners = (canvas, isEditMode = false) => {
    // å­˜å‚¨canvaså¼•ç”¨ä»¥ä¾¿åœ¨æ‹–æ‹½äº‹ä»¶ä¸­ä½¿ç”¨
    canvas.dataset.isCanvas = 'true';
    
    // åªåœ¨é¢œè‰²æ›´æ¢æ¨¡å¼ä¸‹å¯ç”¨ç‚¹å‡»äº‹ä»¶
    if (state.isReplaceMode) {
        canvas.style.cursor = 'pointer';
        
        canvas.onclick = (e) => {
            e.stopPropagation();
            const coords = getCanvasCoordinates(canvas, e);
            
            if (coords.x >= state.minX && coords.x <= state.maxX && 
                coords.y >= state.minY && coords.y <= state.maxY) {
                const key = state.colorData[coords.y][coords.x];
                if (key) {
                    state.selectedColor = key;
                    state.selectedCell = { x: coords.x, y: coords.y, color: key };
                    showColorPicker();
                }
            }
        };
        
        canvas.ontouchstart = (e) => {
            e.preventDefault();
            e.stopPropagation();
            const coords = getCanvasCoordinates(canvas, e);
            
            if (coords.x >= state.minX && coords.x <= state.maxX && 
                coords.y >= state.minY && coords.y <= state.maxY) {
                const key = state.colorData[coords.y][coords.x];
                if (key) {
                    state.selectedColor = key;
                    state.selectedCell = { x: coords.x, y: coords.y, color: key };
                    showColorPicker();
                }
            }
        };
    } else {
        // éé¢œè‰²æ›´æ¢æ¨¡å¼ä¸‹çš„é»˜è®¤æ ·å¼ - ç§»é™¤ç‚¹å‡»é€‰æ‹©é¢œè‰²åŠŸèƒ½
        canvas.style.cursor = 'default';
        
        // ç§»é™¤éé¢œè‰²æ›´æ¢æ¨¡å¼ä¸‹çš„ç‚¹å‡»äº‹ä»¶å¤„ç†
        // ä¸å†è®¾ç½®canvas.onclickå’Œcanvas.ontouchstart
    }
};

// ä¿®å¤ï¼šå…³é”® - é‡æ–°ç»‘å®šç¼–è¾‘æ¨¡å¼åŠŸèƒ½äº‹ä»¶ç›‘å¬å™¨
const bindEditModeEvents = () => {
    console.log('é‡æ–°ç»‘å®šç¼–è¾‘æ¨¡å¼äº‹ä»¶ç›‘å¬å™¨');
    
    // é¢œè‰²æ“ä½œæŒ‰é’®
    const highlightBtn = document.getElementById('edit-highlight-btn');
    const hideBtn = document.getElementById('edit-hide-btn');
    const clearBtn = document.getElementById('edit-clear-highlight-btn');
    
    if (highlightBtn) {
        highlightBtn.onclick = () => {
            if (state.selectedColor) {
                state.highlightedColor = state.highlightedColor === state.selectedColor ? null : state.selectedColor;
                renderCanvas(true, true); // ä¿æŒç¼©æ”¾çŠ¶æ€
            } else {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªé¢œè‰²');
            }
        };
    }
    
    if (hideBtn) {
        hideBtn.onclick = () => {
            if (state.selectedColor) {
                if (state.hiddenColors.has(state.selectedColor)) {
                    state.hiddenColors.delete(state.selectedColor);
                } else {
                    state.hiddenColors.add(state.selectedColor);
                }
                renderCanvas(true, true); // ä¿æŒç¼©æ”¾çŠ¶æ€
            } else {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªé¢œè‰²');
            }
        };
    }
    
    if (clearBtn) {
        clearBtn.onclick = () => {
            state.highlightedColor = null;
            state.hiddenColors.clear();
            renderCanvas(true, true); // ä¿æŒç¼©æ”¾çŠ¶æ€
        };
    }
    
    // æ˜¾ç¤ºé€‰é¡¹å¤é€‰æ¡†
    const showGridCheckbox = document.getElementById('edit-show-grid');
    const showCoordsCheckbox = document.getElementById('edit-show-coords');
    const showColorsCheckbox = document.getElementById('edit-show-colors');
    const showBackgroundCheckbox = document.getElementById('edit-show-background');
    
    if (showGridCheckbox) {
        showGridCheckbox.onchange = (e) => {
            state.showGrid = e.target.checked;
            renderCanvas(true, true); // ä¿æŒç¼©æ”¾çŠ¶æ€
        };
    }
    
    if (showCoordsCheckbox) {
        showCoordsCheckbox.onchange = (e) => {
            state.showCoords = e.target.checked;
            renderCanvas(true, true); // ä¿æŒç¼©æ”¾çŠ¶æ€
        };
    }
    
    if (showColorsCheckbox) {
        showColorsCheckbox.onchange = (e) => {
            state.showColors = e.target.checked;
            renderCanvas(true, true); // ä¿æŒç¼©æ”¾çŠ¶æ€
        };
    }
    
    if (showBackgroundCheckbox) {
        showBackgroundCheckbox.onchange = (e) => {
            state.showBackground = e.target.checked;
            renderCanvas(true, true); // ä¿æŒç¼©æ”¾çŠ¶æ€
        };
    }
    
    // é¢œè‰²æ›´æ¢åŠŸèƒ½å¼€å…³
    const colorReplaceToggle = document.getElementById('color-replace-toggle');
    if (colorReplaceToggle) {
        // ç§»é™¤ä¹‹å‰çš„äº‹ä»¶ç›‘å¬å™¨
        const newToggle = colorReplaceToggle.cloneNode(true);
        colorReplaceToggle.parentNode.replaceChild(newToggle, colorReplaceToggle);
        
        newToggle.addEventListener('click', function() {
            state.isReplaceMode = !state.isReplaceMode;
            this.classList.toggle('active');
            
            // æ›´æ–°å¼€å…³æ˜¾ç¤º
            const labels = this.parentElement.querySelectorAll('.toggle-label');
            if (state.isReplaceMode) {
                labels[0].style.opacity = '0.5';
                labels[1].style.opacity = '1';
                labels[0].style.fontWeight = 'normal';
                labels[1].style.fontWeight = 'bold';
            } else {
                labels[0].style.opacity = '1';
                labels[1].style.opacity = '0.5';
                labels[0].style.fontWeight = 'bold';
                labels[1].style.fontWeight = 'normal';
            }
            
            console.log('é¢œè‰²æ›´æ¢åŠŸèƒ½:', state.isReplaceMode ? 'å¼€å¯' : 'å…³é—­');
            
            // ä¿®å¤ï¼šé‡æ–°æ¸²æŸ“ç”»å¸ƒä»¥åº”ç”¨æˆ–ç§»é™¤ç‚¹å‡»äº‹ä»¶ï¼Œä¿æŒç¼©æ”¾çŠ¶æ€
            renderCanvas(state.isEditMode, true);
        });
    }
    
    // ä¸‹è½½æŒ‰é’®
    const downloadBtn = document.getElementById('edit-download-btn');
    if (downloadBtn) {
        downloadBtn.onclick = () => {
            downloadPattern(true);
        };
    }
    
    console.log('ç¼–è¾‘æ¨¡å¼äº‹ä»¶ç›‘å¬å™¨ç»‘å®šå®Œæˆ');
};

const renderShoppingList = () => {
    const listItems = document.getElementById('list-items');
    listItems.innerHTML = '';
    const sorted = Object.entries(state.colorCounts).sort((a,b)=>b[1]-a[1]);
    sorted.forEach(([key, count]) => {
        const item = document.createElement('div'); 
        item.className = 'list-item';
        item.style.cursor = 'pointer';
        item.innerHTML = `
            <div class="list-swatch" style="background:${MARD_COLORS_FULL[key]}"></div>
            <span><strong>${key}</strong></span>
            <span style="margin-left:auto; font-weight:600;">Ã—${count}</span>
        `;
        item.onclick = () => {
            state.selectedColor = key;
        };
        listItems.appendChild(item);
    });
};

// --- Color Picker Functions ---
const showColorPicker = () => {
    const colorPickerGrid = document.getElementById('color-picker-grid');
    colorPickerGrid.innerHTML = '';
    
    // Sort colors by name for better organization
    const sortedColors = Object.entries(MARD_COLORS_FULL);
    
    sortedColors.forEach(([key, color]) => {
        const item = document.createElement('div');
        item.className = 'color-picker-item';
        item.dataset.color = key;
        
        // Create color preview
        const colorDiv = document.createElement('div');
        colorDiv.className = 'color-picker-color';
        colorDiv.style.backgroundColor = color;
        
        // Create color label
        const label = document.createElement('div');
        label.className = 'color-picker-label';
        label.textContent = key;
        
        item.appendChild(colorDiv);
        item.appendChild(label);
        
        if (key === state.selectedCell?.color) {
            item.classList.add('selected');
        }
        
        item.onclick = () => {
            // Update selected cell with new color
            if (state.selectedCell) {
                const oldColor = state.colorData[state.selectedCell.y][state.selectedCell.x];
                state.colorData[state.selectedCell.y][state.selectedCell.x] = key;
                
                // Update color counts
                state.colorCounts[oldColor]--;
                state.colorCounts[key] = (state.colorCounts[key] || 0) + 1;
                
                // Clean up zero counts
                if (state.colorCounts[oldColor] <= 0) {
                    delete state.colorCounts[oldColor];
                }
                
                // ä¿®å¤ï¼šå…³é”® - ä½¿ç”¨ preserveZoom=true ä¿æŒç¼©æ”¾çŠ¶æ€
                renderCanvas(state.isEditMode, true);
                renderShoppingList();
                document.getElementById('color-picker-modal').style.display = 'none';
            }
        };
        
        colorPickerGrid.appendChild(item);
    });
    
    document.getElementById('color-picker-modal').style.display = 'flex';
};

// --- UI & Event Handlers ---
const updateStatus = () => {
    const processingModeEl = document.getElementById('processing-mode');
    const mergedRegionsEl = document.getElementById('merged-regions');
    const backgroundRemovedEl = document.getElementById('background-removed');
    
    if (processingModeEl) processingModeEl.textContent = state.processingMode;
    if (mergedRegionsEl) mergedRegionsEl.textContent = state.mergedRegions + 'ä¸ªåŒºåŸŸ';
    if (backgroundRemovedEl) backgroundRemovedEl.textContent = state.backgroundRemoved;
};

const initializeUI = () => {
    // Preset buttons
    Object.keys(COLOR_PRESETS).forEach(name => {
        const btn = document.createElement('button'); 
        btn.className = 'preset-btn'; 
        btn.textContent = name;
        btn.onclick = () => { 
            state.activePalette = COLOR_PRESETS[name]; 
            document.querySelectorAll('.preset-btn').forEach(b=>b.classList.remove('active')); 
            btn.classList.add('active'); 
            // Auto process if image is loaded
            if (state.originalImage) {
                processImage();
            }
        };
        if (name === 'å…¨è‰²ç³»291è‰²') btn.classList.add('active');
        document.getElementById('preset-buttons').appendChild(btn);
    });

    const customBtn = document.createElement('button'); 
    customBtn.className = 'preset-btn'; 
    customBtn.textContent = 'è‡ªå®šä¹‰';
    customBtn.onclick = () => {
        const customColorSection = document.getElementById('custom-color-section');
        customColorSection.style.display = customColorSection.style.display === 'none' ? 'block' : 'none';
        if(customColorSection.style.display === 'block') renderCustomColorGrid();
    };
    document.getElementById('preset-buttons').appendChild(customBtn);
};

const renderCustomColorGrid = () => {
    const customColorGrid = document.getElementById('custom-color-grid');
    customColorGrid.innerHTML = '';
    ALL_COLOR_KEYS.forEach(key => {
        const swatch = document.createElement('div'); 
        swatch.className = 'color-swatch';
        swatch.style.backgroundColor = MARD_COLORS_FULL[key];
        swatch.dataset.key = key;
        
        // Add tooltip
        const tooltip = document.createElement('span');
        tooltip.textContent = key;
        swatch.appendChild(tooltip);
        
        if (state.customPalette.has(key)) swatch.classList.add('active');
        swatch.onclick = () => {
            if(state.customPalette.has(key)) state.customPalette.delete(key);
            else state.customPalette.add(key);
            renderCustomColorGrid();
        };
        customColorGrid.appendChild(swatch);
    });
};

const updateExcludedColorsDisplay = () => {
    const excludedColorsDiv = document.getElementById('edit-excluded-colors');
    excludedColorsDiv.innerHTML = '';
    state.excludedColors.forEach(colorKey => {
        const item = document.createElement('div');
        item.className = 'excluded-color-item';
        item.innerHTML = `
            <div class="excluded-color-swatch" style="background:${MARD_COLORS_FULL[colorKey]}"></div>
            <span>${colorKey}</span>
            <span class="remove-exclusion" data-color="${colorKey}">âœ•</span>
        `;
        excludedColorsDiv.appendChild(item);
    });
    
    // Add click handlers for removal buttons
    excludedColorsDiv.querySelectorAll('.remove-exclusion').forEach(btn => {
        btn.onclick = () => {
            const colorKey = btn.dataset.color;
            state.excludedColors.delete(colorKey);
            updateExcludedColorsDisplay();
            
            // Reprocess if we have data
            if (state.colorData.length > 0) {
                processImage();
            }
        };
    });
};

// --- File Handling ---
const handleFile = (file) => {
    if (!file) return;
    
    console.log('å¤„ç†æ–‡ä»¶:', file.name, file.type, file.size);
    
    // éªŒè¯æ–‡ä»¶ç±»å‹
    if (!file.type.match(/image\/(jpeg|jpg|png|gif)/i)) {
        alert('è¯·é€‰æ‹©æœ‰æ•ˆçš„å›¾ç‰‡æ–‡ä»¶ (JPG, PNG, GIF)');
        return;
    }
    
    const reader = new FileReader();
    reader.onload = (e) => {
        console.log('æ–‡ä»¶è¯»å–å®Œæˆ');
        const img = new Image();
        img.onload = () => { 
            console.log('å›¾ç‰‡åŠ è½½æˆåŠŸï¼Œå°ºå¯¸:', img.width, 'x', img.height);
            state.originalImage = img;
            
            // åˆ‡æ¢åˆ°ä¸»åº”ç”¨ç•Œé¢
            document.getElementById('home-screen').style.display = 'none';
            document.getElementById('app-screen').style.display = 'block';
            
            // Auto update dimensions based on aspect ratio
            if (img.width && img.height) {
                const aspectRatio = img.height / img.width;
                const widthInput = document.getElementById('width-input');
                const heightInput = document.getElementById('height-input');
                const granularityDisplay = document.getElementById('granularity-display');
                
                heightInput.value = Math.round(widthInput.value * aspectRatio);
                granularityDisplay.textContent = `${widthInput.value} Ã— ${heightInput.value}`;
            }
            
            // Auto process image
            processImage();
        };
        img.onerror = () => {
            console.error('å›¾ç‰‡åŠ è½½å¤±è´¥');
            alert('å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œè¯·é‡è¯•');
        };
        img.src = e.target.result;
    };
    reader.onerror = () => {
        console.error('æ–‡ä»¶è¯»å–å¤±è´¥');
        alert('æ–‡ä»¶è¯»å–å¤±è´¥ï¼Œè¯·é‡è¯•');
    };
    reader.readAsDataURL(file);
};

// --- è®¾å¤‡å…¼å®¹æ€§æ£€æµ‹ ---
const detectDeviceCompatibility = () => {
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    const isOldIOS = isIOS && /OS [1-9]_/.test(navigator.userAgent);
    const isAndroid = /Android/.test(navigator.userAgent);
    const isOldAndroid = isAndroid && /Android [1-4]/.test(navigator.userAgent);
    const isWeChat = /micromessenger/i.test(navigator.userAgent);
    const isLowMemory = navigator.deviceMemory && navigator.deviceMemory < 2;
    const isSlowCPU = navigator.hardwareConcurrency && navigator.hardwareConcurrency < 4;
    
    return {
        isIOS,
        isOldIOS,
        isAndroid,
        isOldAndroid,
        isWeChat,
        isLowMemory,
        isSlowCPU,
        isLowEnd: isOldIOS || isOldAndroid || isLowMemory || isSlowCPU,
        needsCompatibilityMode: isWeChat && isIOS
    };
};

// --- å®Œå…¨é‡å†™çš„ä¸‹è½½å‡½æ•° - è§£å†³æ‰€æœ‰å…¼å®¹æ€§é—®é¢˜ ---
const downloadPattern = (isEditMode = false) => {
    if (!state.colorData || state.colorData.length === 0) {
        alert('è¯·å…ˆç”Ÿæˆå›¾çº¸');
        return;
    }
    
    console.log('=== å¼€å§‹ç”Ÿæˆé«˜è´¨é‡å›¾çº¸ ===');
    
    // æ£€æµ‹è®¾å¤‡å…¼å®¹æ€§
    const deviceInfo = detectDeviceCompatibility();
    console.log('è®¾å¤‡ä¿¡æ¯:', deviceInfo);
    
    // æ˜¾ç¤ºå…¼å®¹æ€§è­¦å‘Š
    const warningDiv = document.getElementById('compatibility-warning');
    if (deviceInfo.isLowEnd || deviceInfo.needsCompatibilityMode) {
        warningDiv.style.display = 'block';
    } else {
        warningDiv.style.display = 'none';
    }
    
    try {
        // åˆ›å»ºé«˜è´¨é‡ç”»å¸ƒ
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // æ ¹æ®è®¾å¤‡èƒ½åŠ›è°ƒæ•´å‚æ•°
        const hdCellSize = deviceInfo.isLowEnd ? 20 : 30; // ä½ç«¯è®¾å¤‡ä½¿ç”¨æ›´å°çš„å•å…ƒæ ¼
        const coordSize = state.showCoords ? 60 : 20;
        const padding = state.showCoords ? 80 : 40;
        
        // è®¡ç®—å®é™…å†…å®¹è¾¹ç•Œ
        let minX = state.colorData[0].length;
        let maxX = 0;
        let minY = state.colorData.length;
        let maxY = 0;
        let hasContent = false;
        
        for(let y = 0; y < state.colorData.length; y++) {
            for(let x = 0; x < state.colorData[y].length; x++) {
                const key = state.colorData[y][x];
                if (!key) continue;
                
                if (!(state.externalBackground[y] && state.externalBackground[y][x]) && 
                    !state.hiddenColors.has(key)) {
                    hasContent = true;
                    minX = Math.min(minX, x);
                    maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y);
                    maxY = Math.max(maxY, y);
                }
            }
        }
        
        if (!hasContent) {
            alert('æ²¡æœ‰å¯å¯¼å‡ºçš„å†…å®¹');
            return;
        }
        
        // é™åˆ¶æœ€å¤§å°ºå¯¸ï¼Œé¿å…å†…å­˜é—®é¢˜
        const actualWidth = Math.min(maxX - minX + 1, deviceInfo.isLowEnd ? 40 : 60);
        const actualHeight = Math.min(maxY - minY + 1, deviceInfo.isLowEnd ? 40 : 60);
        
        // è®¡ç®—ææ–™è¡¨æ‰€éœ€ç©ºé—´
        const sorted = Object.entries(state.colorCounts).sort((a,b)=>b[1]-a[1]);
        const itemsPerRow = Math.floor(1080 / 150); // é€‚é…æ‰‹æœºå±å¹•å®½åº¦
        const rowsNeeded = Math.ceil(sorted.length / itemsPerRow);
        const listHeight = rowsNeeded * 110 + 100; // æ¯è¡Œé«˜åº¦110pxï¼ŒåŠ ä¸Šæ ‡é¢˜é—´è·
        
        // é‡æ–°è®¡ç®—ç”»å¸ƒé«˜åº¦ - ç¡®ä¿åŒ…å«å®Œæ•´ææ–™è¡¨
        canvas.width = Math.max(1080, actualWidth * hdCellSize + padding); // æœ€å°å®½åº¦1080pxé€‚é…æ‰‹æœº
        canvas.height = actualHeight * hdCellSize + padding + listHeight + 200; // å¢åŠ é¢å¤–ç©ºé—´ç¡®ä¿ææ–™è¡¨å®Œæ•´æ˜¾ç¤º
        
        console.log(`ç”»å¸ƒå°ºå¯¸: ${canvas.width} x ${canvas.height}`);
        
        // è®¾ç½®èƒŒæ™¯
        ctx.imageSmoothingEnabled = false;
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // ç»˜åˆ¶åæ ‡æ ‡ç­¾
        if (state.showCoords) {
            ctx.font = 'bold 32px Arial'; 
            ctx.textAlign = 'center'; 
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#333333';
            
            for(let x = minX; x <= maxX && x < minX + actualWidth; x++) {
                const label = (x + 1).toString();
                const xPos = (x - minX) * hdCellSize + hdCellSize/2 + padding/2;
                ctx.fillText(label, xPos, padding/2 - 40);
            }
            
            for(let y = minY; y <= maxY && y < minY + actualHeight; y++) {
                const label = (y + 1).toString();
                const yPos = (y - minY) * hdCellSize + hdCellSize/2 + padding/2;
                ctx.fillText(label, padding/2 - 40, yPos);
            }
        }

        // ç»˜åˆ¶å›¾æ¡ˆ
        const offsetX = state.showCoords ? padding/2 : 40;
        const offsetY = state.showCoords ? padding/2 : 40;
        
        for(let y = minY; y <= maxY && y < minY + actualHeight; y++) {
            for(let x = minX; x <= maxX && x < minX + actualWidth; x++) {
                const key = state.colorData[y][x];
                if (!key) continue;
                
                const px = (x - minX) * hdCellSize + offsetX;
                const py = (y - minY) * hdCellSize + offsetY;
                
                // è·³è¿‡éšè—çš„é¢œè‰²
                if (state.hiddenColors.has(key)) {
                    ctx.fillStyle = '#f8f8f8';
                    ctx.fillRect(px, py, hdCellSize, hdCellSize);
                    ctx.strokeStyle = '#e0e0e0';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(px, py, hdCellSize, hdCellSize);
                    continue;
                }
                
                // è·³è¿‡å¤–éƒ¨èƒŒæ™¯ï¼ˆå¦‚æœä¸æ˜¾ç¤ºèƒŒæ™¯ï¼‰
                if (!state.showBackground && state.externalBackground[y] && state.externalBackground[y][x]) continue;
                
                // ç»˜åˆ¶ç å­
                if (state.externalBackground[y] && state.externalBackground[y][x]) {
                    ctx.fillStyle = '#f0f0f0';
                } else {
                    ctx.fillStyle = MARD_COLORS_FULL[key];
                }
                ctx.fillRect(px, py, hdCellSize, hdCellSize);
                
                // ç»˜åˆ¶ç½‘æ ¼
                if (state.showGrid) {
                    ctx.strokeStyle = '#dddddd';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(px, py, hdCellSize, hdCellSize);
                }
                
                // é«˜äº®ç›¸åŒé¢œè‰²
                if (state.highlightedColor === key) {
                    ctx.fillStyle = 'rgba(255, 200, 0, 0.4)';
                    ctx.fillRect(px, py, hdCellSize, hdCellSize);
                    ctx.strokeStyle = '#ff9500';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(px, py, hdCellSize, hdCellSize);
                    ctx.lineWidth = 1;
                }
                
                // ç»˜åˆ¶è‰²å·
                if (state.showColors && !(state.externalBackground[y] && state.externalBackground[y][x]) && !state.hiddenColors.has(key)) {
                    const rgb = hexToRgb(MARD_COLORS_FULL[key]);
                    const brightness = (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
                    ctx.fillStyle = brightness > 140 ? '#000000' : '#ffffff';
                    
                    const fontSize = Math.min(hdCellSize * 0.4, 18);
                    ctx.font = `bold ${fontSize}px Arial`;
                    ctx.textAlign = 'center'; 
                    ctx.textBaseline = 'middle';
                    
                    const text = key;
                    ctx.fillText(text, px + hdCellSize/2, py + hdCellSize/2);
                }
            }
        }
        
        // ç»˜åˆ¶ææ–™æ¸…å• - ä¿®å¤å¸ƒå±€é—®é¢˜
        const listY = actualHeight * hdCellSize + offsetY + 50;
        ctx.font = 'bold 24px Arial';
        ctx.fillStyle = '#333333';
        ctx.textAlign = 'left';
        ctx.fillText('ğŸ“¦ ææ–™æ¸…å•:', 50, listY);
        
        // é‡æ–°è®¡ç®—ææ–™è¡¨å¸ƒå±€ - ç¡®ä¿åœ¨æ‰‹æœºä¸Šå®Œæ•´æ˜¾ç¤º
        const itemWidth = 140;
        const itemHeight = 90;
        const itemsPerRowFixed = Math.floor((canvas.width - 100) / (itemWidth + 20));
        
        sorted.forEach(([key, count], index) => {
            const col = index % itemsPerRowFixed;
            const row = Math.floor(index / itemsPerRowFixed);
            const itemX = 50 + col * (itemWidth + 20);
            const itemY = listY + 50 + row * (itemHeight + 20);
            
            // ç¡®ä¿ä¸ä¼šè¶…å‡ºç”»å¸ƒåº•éƒ¨
            if (itemY + itemHeight > canvas.height - 50) {
                console.warn(`ææ–™è¡¨é¡¹ç›® ${key} è¶…å‡ºç”»å¸ƒè¾¹ç•Œ`);
                return;
            }
            
            ctx.fillStyle = MARD_COLORS_FULL[key];
            ctx.fillRect(itemX, itemY, 45, 45);
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 2;
            ctx.strokeRect(itemX, itemY, 45, 45);
            
            ctx.fillStyle = '#333333';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(key, itemX + 55, itemY + 20);
            ctx.font = 'bold 16px Arial';
            ctx.fillText(`Ã—${count}`, itemX + 55, itemY + 45);
        });
        
        // ç»˜åˆ¶ç‰ˆæƒä¿¡æ¯
        ctx.font = '14px Arial';
        ctx.fillStyle = '#666666';
        ctx.textAlign = 'center';
        ctx.fillText('æ‹¼è±†å›¾çº¸ç”Ÿæˆå™¨-è¥¿ç“œå“¥åˆ¶ä½œ', canvas.width/2, canvas.height - 60);
        ctx.fillText('ç‰ˆæƒå·²ç™»è®°ï¼Œä»…æˆæƒäºæ·˜å®åº—é“ºï¼šå¤§å¸ˆç²¾å“èµ„æ–™', canvas.width/2, canvas.height - 35);
        
        console.log('å›¾çº¸ç»˜åˆ¶å®Œæˆï¼Œå¼€å§‹ä¸‹è½½å¤„ç†...');
        
        // å¤šé‡ä¸‹è½½ç­–ç•¥ - ç¡®ä¿å…¼å®¹æ€§
        const tryDownload = async () => {
            console.log('å°è¯•ä¸‹è½½ç­–ç•¥...');
            
            // ç­–ç•¥1: ä½¿ç”¨toBlob (ç°ä»£æµè§ˆå™¨)
            if (canvas.toBlob) {
                try {
                    console.log('å°è¯•ä½¿ç”¨toBlobæ–¹æ³•...');
                    const blob = await new Promise((resolve, reject) => {
                        canvas.toBlob((blob) => {
                            if (blob && blob.size > 1000) {
                                console.log(`Blobåˆ›å»ºæˆåŠŸï¼Œå¤§å°: ${blob.size} bytes`);
                                resolve(blob);
                            } else {
                                console.warn('Blobå¤§å°å¼‚å¸¸æˆ–ä¸ºç©º');
                                reject(new Error('Blob size invalid'));
                            }
                        }, 'image/png', 0.9);
                    });
                    
                    if (blob) {
                        downloadFromBlob(blob, `æ‹¼è±†å›¾çº¸_${Date.now()}.png`);
                        return;
                    }
                } catch (error) {
                    console.warn('Blobæ–¹æ³•å¤±è´¥:', error);
                }
            }
            
            // ç­–ç•¥2: ä½¿ç”¨toDataURL
            try {
                console.log('å°è¯•ä½¿ç”¨toDataURLæ–¹æ³•...');
                const dataURL = canvas.toDataURL('image/png', 0.9);
                if (dataURL && dataURL.length > 100 && !dataURL.includes('data:,')) {
                    console.log(`DataURLåˆ›å»ºæˆåŠŸï¼Œé•¿åº¦: ${dataURL.length}`);
                    downloadFromDataURL(dataURL, `æ‹¼è±†å›¾çº¸_${Date.now()}.png`);
                    return;
                }
            } catch (error) {
                console.warn('DataURLæ–¹æ³•å¤±è´¥:', error);
            }
            
            // ç­–ç•¥3: ä½¿ç”¨JPEGæ ¼å¼ï¼ˆæ›´å…¼å®¹ï¼‰
            try {
                console.log('å°è¯•ä½¿ç”¨JPEGæ ¼å¼...');
                const dataURL = canvas.toDataURL('image/jpeg', 0.8);
                if (dataURL && dataURL.length > 100) {
                    console.log(`JPEGåˆ›å»ºæˆåŠŸï¼Œé•¿åº¦: ${dataURL.length}`);
                    downloadFromDataURL(dataURL, `æ‹¼è±†å›¾çº¸_${Date.now()}.jpg`);
                    return;
                }
            } catch (error) {
                console.warn('JPEGæ–¹æ³•å¤±è´¥:', error);
            }
            
            // ç­–ç•¥4: åœ¨æ–°çª—å£æ˜¾ç¤ºï¼ˆæœ€ç»ˆå¤‡ç”¨æ–¹æ¡ˆï¼‰
            console.log('ä½¿ç”¨æ–°çª—å£æ˜¾ç¤ºæ–¹æ¡ˆ...');
            showInNewWindow(canvas);
        };
        
        // Blobä¸‹è½½å¤„ç†
        const downloadFromBlob = (blob, filename) => {
            console.log(`ä»Blobä¸‹è½½: ${filename}, å¤§å°: ${blob.size} bytes`);
            
            // æ£€æµ‹ç¯å¢ƒ
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (isIOS || isMobile) {
                // ç§»åŠ¨ç«¯ç‰¹æ®Šå¤„ç†
                console.log('ä½¿ç”¨ç§»åŠ¨ç«¯ä¸‹è½½æ–¹æ¡ˆ');
                const reader = new FileReader();
                reader.onload = function(e) {
                    const dataURL = e.target.result;
                    downloadFromDataURL(dataURL, filename);
                };
                reader.onerror = function() {
                    console.error('FileReaderè¯»å–å¤±è´¥');
                    showInNewWindow(canvas);
                };
                reader.readAsDataURL(blob);
            } else {
                // æ¡Œé¢ç«¯å¤„ç†
                console.log('ä½¿ç”¨æ¡Œé¢ç«¯ä¸‹è½½æ–¹æ¡ˆ');
                try {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    link.style.display = 'none';
                    document.body.appendChild(link);
                    
                    // å¤šç§è§¦å‘æ–¹å¼
                    if (link.click) {
                        link.click();
                    } else if (link.dispatchEvent) {
                        const event = new MouseEvent('click', {
                            view: window,
                            bubbles: true,
                            cancelable: true
                        });
                        link.dispatchEvent(event);
                    }
                    
                    setTimeout(() => {
                        document.body.removeChild(link);
                        URL.revokeObjectURL(url);
                    }, 100);
                    
                    console.log('æ¡Œé¢ç«¯ä¸‹è½½å®Œæˆ');
                } catch (error) {
                    console.error('æ¡Œé¢ç«¯ä¸‹è½½å¤±è´¥:', error);
                    showInNewWindow(canvas);
                }
            }
        };
        
        // DataURLä¸‹è½½å¤„ç†
        const downloadFromDataURL = (dataURL, filename) => {
            console.log(`ä»DataURLä¸‹è½½: ${filename}`);
            
            try {
                const link = document.createElement('a');
                link.href = dataURL;
                link.download = filename;
                link.style.display = 'none';
                document.body.appendChild(link);
                
                // ç§»åŠ¨ç«¯å…¼å®¹æ€§å¤„ç†
                if (navigator.userAgent.includes('iPhone') || navigator.userAgent.includes('iPad')) {
                    // iOSç‰¹æ®Šå¤„ç†
                    link.target = '_blank';
                }
                
                // è§¦å‘ä¸‹è½½
                if (link.click) {
                    link.click();
                } else {
                    // å¤‡ç”¨è§¦å‘æ–¹å¼
                    const event = new MouseEvent('click', {
                        view: window,
                        bubbles: true,
                        cancelable: true
                    });
                    link.dispatchEvent(event);
                }
                
                setTimeout(() => {
                    document.body.removeChild(link);
                }, 100);
                
                console.log('DataURLä¸‹è½½å®Œæˆ');
            } catch (error) {
                console.error('DataURLä¸‹è½½å¤±è´¥:', error);
                showInNewWindow(canvas);
            }
        };
        
        // æ–°çª—å£æ˜¾ç¤º
        const showInNewWindow = (canvas) => {
            console.log('åœ¨æ–°çª—å£æ˜¾ç¤ºå›¾çº¸');
            
            try {
                const dataURL = canvas.toDataURL('image/png', 0.8);
                const newWindow = window.open('', '_blank');
                
                if (newWindow) {
                    newWindow.document.write(`
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <title>æ‹¼è±†å›¾çº¸ - ${new Date().toLocaleString()}</title>
                            <meta name="viewport" content="width=device-width, initial-scale=1.0">
                            <style>
                                body { 
                                    margin: 0; 
                                    padding: 20px; 
                                    text-align: center; 
                                    font-family: Arial, sans-serif;
                                    background-color: #f5f5f5;
                                }
                                .header {
                                    background: linear-gradient(135deg, #FF69B4, #FFB6C1);
                                    color: white;
                                    padding: 20px;
                                    border-radius: 10px;
                                    margin-bottom: 20px;
                                }
                                img { 
                                    max-width: 100%; 
                                    height: auto; 
                                    border: 2px solid #ddd;
                                    border-radius: 5px;
                                    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
                                }
                                .instructions { 
                                    margin: 20px 0; 
                                    color: #666;
                                    background: white;
                                    padding: 15px;
                                    border-radius: 5px;
                                }
                                .footer {
                                    margin-top: 20px;
                                    font-size: 12px;
                                    color: #999;
                                }
                            </style>
                        </head>
                        <body>
                            <div class="header">
                                <h2>ğŸŒ¸ æ‹¼è±†å›¾çº¸ç”ŸæˆæˆåŠŸï¼</h2>
                                <p>ç”Ÿæˆæ—¶é—´: ${new Date().toLocaleString()}</p>
                            </div>
                            <div class="instructions">
                                <h3>ä¿å­˜è¯´æ˜:</h3>
                                <p><strong>æ‰‹æœºç”¨æˆ·:</strong> é•¿æŒ‰ä¸‹æ–¹å›¾ç‰‡é€‰æ‹©"ä¿å­˜å›¾ç‰‡"</p>
                                <p><strong>ç”µè„‘ç”¨æˆ·:</strong> å³é”®å›¾ç‰‡é€‰æ‹©"å›¾ç‰‡å¦å­˜ä¸º"</p>
                                <p><strong>å¦‚æœæ— æ³•ä¿å­˜:</strong> è¯·æˆªå›¾ä¿å­˜å½“å‰é¡µé¢</p>
                            </div>
                            <img src="${dataURL}" alt="æ‹¼è±†å›¾çº¸" />
                            <div class="footer">
                                <p>æ‹¼è±†å›¾çº¸ç”Ÿæˆå™¨-è¥¿ç“œå“¥åˆ¶ä½œ</p>
                                <p>ç‰ˆæƒå·²ç™»è®°ï¼Œä»…æˆæƒäºæ·˜å®åº—é“ºï¼šå¤§å¸ˆç²¾å“èµ„æ–™</p>
                            </div>
                        </body>
                        </html>
                    `);
                    console.log('æ–°çª—å£æ˜¾ç¤ºæˆåŠŸ');
                } else {
                    console.error('æ— æ³•æ‰“å¼€æ–°çª—å£ï¼Œå¯èƒ½æ˜¯æµè§ˆå™¨é˜»æ­¢äº†å¼¹çª—');
                    alert('æ— æ³•æ‰“å¼€æ–°çª—å£ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨å¼¹çª—è®¾ç½®ï¼Œæˆ–å°è¯•æˆªå›¾ä¿å­˜');
                }
            } catch (error) {
                console.error('æ–°çª—å£æ˜¾ç¤ºå¤±è´¥:', error);
                alert('æ˜¾ç¤ºå¤±è´¥ï¼Œè¯·å°è¯•æˆªå›¾ä¿å­˜');
            }
        };
        
        // æ‰§è¡Œä¸‹è½½
        tryDownload();
        
    } catch (error) {
        console.error('ç”Ÿæˆå›¾çº¸å¤±è´¥:', error);
        alert('ç”Ÿæˆå›¾çº¸å¤±è´¥ï¼Œè¯·é‡è¯•æˆ–è”ç³»æŠ€æœ¯æ”¯æŒ\né”™è¯¯ä¿¡æ¯: ' + error.message);
    }
};

// --- Event Listeners ---

// åˆå§‹åŒ–æ¿€æ´»ç³»ç»Ÿ
document.addEventListener('DOMContentLoaded', function() {
    console.log('=== é¡µé¢åŠ è½½å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ– ===');
    
    // é¦–å…ˆåˆå§‹åŒ–æ¿€æ´»ç³»ç»Ÿ
    initializeActivation();
    
    // Home screen upload
    const homeUploadArea = document.getElementById('home-upload-area');
    const homeFileInput = document.getElementById('home-file-input');
    
    if (homeUploadArea && homeFileInput) {
        // ç‚¹å‡»ä¸Šä¼ 
        homeUploadArea.addEventListener('click', () => {
            console.log('ç‚¹å‡»ä¸Šä¼ åŒºåŸŸ');
            homeFileInput.click();
        });
        
        // æ–‡ä»¶é€‰æ‹©
        homeFileInput.addEventListener('change', (e) => {
            console.log('æ–‡ä»¶é€‰æ‹©å˜åŒ–', e.target.files);
            if (e.target.files && e.target.files[0]) {
                handleFile(e.target.files[0]);
            }
        });
        
        // æ‹–æ‹½ä¸Šä¼ 
        homeUploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            homeUploadArea.classList.add('dragover');
        });
        
        homeUploadArea.addEventListener('dragleave', () => {
            homeUploadArea.classList.remove('dragover');
        });
        
        homeUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            homeUploadArea.classList.remove('dragover');
            if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                handleFile(e.dataTransfer.files[0]);
            }
        });
    }
    
    // App screen upload
    const uploadArea = document.getElementById('upload-area');
    const fileInput = document.getElementById('file-input');
    
    if (uploadArea && fileInput) {
        // ç‚¹å‡»ä¸Šä¼ 
        uploadArea.addEventListener('click', () => {
            console.log('ç‚¹å‡»åº”ç”¨å†…ä¸Šä¼ åŒºåŸŸ');
            fileInput.click();
        });
        
        // æ–‡ä»¶é€‰æ‹©
        fileInput.addEventListener('change', (e) => {
            console.log('åº”ç”¨å†…æ–‡ä»¶é€‰æ‹©å˜åŒ–', e.target.files);
            if (e.target.files && e.target.files[0]) {
                handleFile(e.target.files[0]);
            }
        });
        
        // æ‹–æ‹½ä¸Šä¼ 
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                handleFile(e.dataTransfer.files[0]);
            }
        });
    }
    
    // New image button
    const newImageBtn = document.getElementById('new-image-btn');
    if (newImageBtn) {
        newImageBtn.addEventListener('click', () => {
            // è¿”å›é¦–é¡µ
            document.getElementById('app-screen').style.display = 'none';
            document.getElementById('edit-mode-screen').style.display = 'none';
            document.getElementById('home-screen').style.display = 'flex';
            
            // æ¸…ç©ºçŠ¶æ€
            state.originalImage = null;
            state.colorData = [];
            state.initialMappedData = [];
            state.mergedData = [];
            state.externalBackground = [];
            state.colorCounts = {};
            state.highlightedColor = null;
            state.hiddenColors.clear();
            state.selectedColor = null;
            state.selectedCell = null;
            state.zoomLevel = 100;
            state.isEditMode = false;
            state.isReplaceMode = false;
            
            // é‡ç½®æ–‡ä»¶è¾“å…¥
            if (homeFileInput) homeFileInput.value = '';
            if (fileInput) fileInput.value = '';
        });
    }
    
    // Edit mode button
    const editModeBtn = document.getElementById('edit-mode-btn');
    const editModeScreen = document.getElementById('edit-mode-screen');
    if (editModeBtn && editModeScreen) {
        editModeBtn.addEventListener('click', () => {
            if (!state.colorData || state.colorData.length === 0) {
                alert('è¯·å…ˆåœ¨ä¸»ç•Œé¢ç”Ÿæˆå›¾çº¸');
                return;
            }
            
            state.isEditMode = true;
            document.getElementById('app-screen').style.display = 'none';
            document.getElementById('home-screen').style.display = 'none';
            document.getElementById('edit-mode-screen').style.display = 'flex';
            renderCanvas(true);
        });
    }
    
    // Back to main button
    const backToMainBtn = document.getElementById('back-to-main-btn');
    if (backToMainBtn) {
        backToMainBtn.addEventListener('click', () => {
            state.isEditMode = false;
            state.isReplaceMode = false;
            document.getElementById('edit-mode-screen').style.display = 'none';
            document.getElementById('app-screen').style.display = 'block';
            document.getElementById('home-screen').style.display = 'none';
        });
    }
    
    // æ–°å¢ï¼šåœ¨æ–°çª—å£æŸ¥çœ‹æŒ‰é’®
    const viewInNewWindowBtn = document.getElementById('view-in-new-window-btn');
    if (viewInNewWindowBtn) {
        viewInNewWindowBtn.addEventListener('click', () => {
            if (!state.colorData || state.colorData.length === 0) {
                alert('è¯·å…ˆç”Ÿæˆå›¾çº¸');
                return;
            }
            
            // å¤åˆ¶downloadPatternä¸­çš„showInNewWindowé€»è¾‘
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            // ... å¤åˆ¶ç»˜åˆ¶é€»è¾‘ ...
            
            try {
                const dataURL = canvas.toDataURL('image/png', 0.8);
                const newWindow = window.open('', '_blank');
                
                if (newWindow) {
                    newWindow.document.write(`
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <title>æ‹¼è±†å›¾çº¸é¢„è§ˆ</title>
                            <meta name="viewport" content="width=device-width, initial-scale=1.0">
                            <style>
                                body { margin: 0; padding: 20px; text-align: center; font-family: Arial, sans-serif; }
                                img { max-width: 100%; height: auto; border: 1px solid #ccc; }
                                .instructions { margin: 20px 0; color: #666; }
                            </style>
                        </head>
                        <body>
                            <div class="instructions">
                                <h3>æ‹¼è±†å›¾çº¸é¢„è§ˆ</h3>
                                <p>è¯·é•¿æŒ‰å›¾ç‰‡ä¿å­˜åˆ°ç›¸å†Œ</p>
                            </div>
                            <img src="${dataURL}" alt="æ‹¼è±†å›¾çº¸" />
                        </body>
                        </html>
                    `);
                } else {
                    alert('æ— æ³•æ‰“å¼€æ–°çª—å£ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨å¼¹çª—è®¾ç½®');
                }
            } catch (error) {
                console.error('æ–°çª—å£æ˜¾ç¤ºå¤±è´¥:', error);
                alert('æ˜¾ç¤ºå¤±è´¥ï¼Œè¯·å°è¯•æˆªå›¾ä¿å­˜');
            }
        });
    }
    
    // æ–°å¢ï¼šæˆªå›¾ä¿å­˜æç¤ºæŒ‰é’®
    const screenshotGuideBtn = document.getElementById('screenshot-guide-btn');
    if (screenshotGuideBtn) {
        screenshotGuideBtn.addEventListener('click', () => {
            alert('æˆªå›¾ä¿å­˜æŒ‡å—ï¼š\n\n1. Androidæ‰‹æœºï¼šåŒæ—¶æŒ‰ ç”µæºé”® + éŸ³é‡ä¸‹é”®\n2. iPhoneï¼šåŒæ—¶æŒ‰ ç”µæºé”® + éŸ³é‡ä¸Šé”®\n3. æˆªå›¾ååˆ°ç›¸å†Œä¸­æŸ¥æ‰¾ä¿å­˜\n\nå¦‚æœæˆªå›¾ä¸å®Œæ•´ï¼Œè¯·å…ˆç¼©æ”¾å›¾çº¸åˆ°åˆé€‚å¤§å°');
        });
    }
    
    // Initialize UI
    initializeUI();
    
    // åˆå§‹åŒ–ç§»åŠ¨è®¾å¤‡ä¼˜åŒ–
    initializeMobileOptimizations();
});

// æ–°å¢ï¼šç§»åŠ¨è®¾å¤‡ä¼˜åŒ–åˆå§‹åŒ–
const initializeMobileOptimizations = () => {
    // æ£€æµ‹ç§»åŠ¨è®¾å¤‡
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    if (isMobile) {
        console.log('æ£€æµ‹åˆ°ç§»åŠ¨è®¾å¤‡ï¼Œåº”ç”¨ä¼˜åŒ–');
        
        // è°ƒæ•´ç¼©æ”¾æ­¥é•¿ä»¥æ›´é€‚åˆç§»åŠ¨è®¾å¤‡
        state.zoomState.step = 5;
        
        // æ·»åŠ è§¦æ‘¸ä¼˜åŒ–
        document.body.style.touchAction = 'manipulation';
    }
};

// Controls
document.getElementById('generate-btn')?.addEventListener('click', processImage);

// Granularity slider
document.getElementById('granularity-slider')?.addEventListener('input', (e) => {
    const value = parseInt(e.target.value);
    state.granularity = value;
    const widthInput = document.getElementById('width-input');
    const heightInput = document.getElementById('height-input');
    const granularityDisplay = document.getElementById('granularity-display');
    
    widthInput.value = value;
    if (state.originalImage) {
        heightInput.value = Math.round(value * (state.originalImage.height / state.originalImage.width));
    } else {
        heightInput.value = value;
    }
    granularityDisplay.textContent = `${value} Ã— ${heightInput.value}`;
    
    // Auto process if image is loaded
    if (state.originalImage) {
        processImage();
    }
});

// Similarity threshold slider
document.getElementById('similarity-threshold')?.addEventListener('input', (e) => {
    state.similarityThreshold = parseInt(e.target.value);
    document.getElementById('threshold-display').textContent = state.similarityThreshold;
    
    // Auto process if image is loaded
    if (state.originalImage) {
        processImage();
    }
});

// ç»‘ä¸€çš„ä¸‹è½½å‡½æ•° - ä¿®å¤ç¼–è¾‘æ¨¡å¼ä¸‹è½½åŠŸèƒ½
document.getElementById('download-btn')?.addEventListener('click', () => {
    downloadPattern(false);
});

document.getElementById('edit-download-btn')?.addEventListener('click', () => {
    downloadPattern(true);
});

// Shopping list
document.getElementById('toggle-list-btn')?.addEventListener('click', () => {
    document.getElementById('shopping-list').classList.toggle('visible');
});

// Color picker
document.getElementById('replace-color-btn')?.addEventListener('click', showColorPicker);
document.getElementById('color-picker-close')?.addEventListener('click', () => {
    document.getElementById('color-picker-modal').style.display = 'none';
});
document.getElementById('color-picker-modal')?.addEventListener('click', (e) => {
    if (e.target.id === 'color-picker-modal') {
        document.getElementById('color-picker-modal').style.display = 'none';
    }
});

// Download stats button
document.getElementById('download-stats-btn')?.addEventListener('click', () => {
    const stats = Object.entries(state.colorCounts)
        .sort((a, b) => b[1] - a[1])
        .map(([key, count]) => `${key}: ${count}ä¸ª`)
        .join('\n');
    
    const blob = new Blob([`æ‹¼è±†å›¾çº¸ææ–™ç»Ÿè®¡\nç”Ÿæˆæ—¶é—´: ${new Date().toLocaleString()}\næ€»é¢œè‰²æ•°: ${Object.keys(state.colorCounts).length}\n\né¢œè‰²ç»Ÿè®¡:\n${stats}`], 
        { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.download = `æ‹¼è±†ææ–™ç»Ÿè®¡_${new Date().getTime()}.txt`;
    link.href = url;
    link.click();
    URL.revokeObjectURL(url);
});

// Save custom palette button
document.getElementById('save-custom-palette')?.addEventListener('click', () => {
    if (state.customPalette.size === 0) {
        alert('è¯·å…ˆé€‰æ‹©è‡ªå®šä¹‰é¢œè‰²');
        return;
    }
    
    state.activePalette = Array.from(state.customPalette);
    document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
    
    // Auto process if image is loaded
    if (state.originalImage) {
        processImage();
    }
    
    alert('è‡ªå®šä¹‰è‰²æ¿å·²ä¿å­˜ï¼');
});

// Help buttons
document.getElementById('help-btn')?.addEventListener('click', () => {
    alert('æ‹¼è±†å›¾çº¸ç”Ÿæˆå™¨ä½¿ç”¨è¯´æ˜ï¼š\n\n1. ä¸Šä¼ å›¾ç‰‡\n2. é€‰æ‹©é¢œè‰²é¢„è®¾\n3. è°ƒæ•´è®¾ç½®å‚æ•°\n4. ç‚¹å‡»ç”Ÿæˆå›¾çº¸\n5. ä¸‹è½½æˆ–ç¼–è¾‘å›¾çº¸\n\nè¯¦ç»†æ•™ç¨‹è¯·è”ç³»æ·˜å®åº—é“ºï¼šå¤§å¸ˆç²¾å“èµ„æ–™');
});

document.getElementById('help-edit-btn')?.addEventListener('click', () => {
    alert('ç¼–è¾‘æ¨¡å¼ä½¿ç”¨è¯´æ˜ï¼š\n\n1. ç‚¹å‡»ç å­æŸ¥çœ‹ä¿¡æ¯\n2. ä½¿ç”¨é«˜äº®åŠŸèƒ½æ ‡è®°ç›¸åŒé¢œè‰²\n3. ä½¿ç”¨éšè—åŠŸèƒ½æš‚æ—¶éšè—æŸäº›é¢œè‰²\n4. å¼€å¯é¢œè‰²æ›´æ¢åŠŸèƒ½å¯ä»¥ä¿®æ”¹å•ä¸ªç å­é¢œè‰²\n5. ä½¿ç”¨ç¼©æ”¾åŠŸèƒ½æŸ¥çœ‹ç»†èŠ‚\n\nè¯¦ç»†æ•™ç¨‹è¯·è”ç³»æ·˜å®åº—é“ºï¼šå¤§å¸ˆç²¾å“èµ„æ–™');
});

// é¢å¤–çš„å¤‡ç”¨åˆå§‹åŒ–
window.addEventListener('load', function() {
    console.log('=== é¡µé¢å®Œå…¨åŠ è½½å®Œæˆ ===');
    // å†æ¬¡æ£€æŸ¥æ¿€æ´»ç³»ç»Ÿæ˜¯å¦æ­£å¸¸åˆå§‹åŒ–
    const activateBtn = document.getElementById('activate-btn');
    if (activateBtn && !activateBtn.hasAttribute('data-initialized')) {
        console.log('å¤‡ç”¨åˆå§‹åŒ–æ¿€æ´»ç³»ç»Ÿ');
        initializeActivation();
        activateBtn.setAttribute('data-initialized', 'true');
    }
});
</script>
</body>
</html>
